<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[Category: ml | Rishijeet Mishra]]></title>
    <link href="https://rishijeet.github.io/blog/categories/ml/atom.xml" rel="self"/>
    <link href="https://rishijeet.github.io/"/>
    <updated>2025-08-17T21:03:59+05:30</updated>
    <id>https://rishijeet.github.io/</id>
    <author>
        <name><![CDATA[Rishijeet Mishra]]></name>
        <email><![CDATA[rishijeet@gmail.com]]></email>
      </author>
    <generator uri="http://octopress.org/">Octopress</generator>

    
    <entry>
        <title type="html"><![CDATA[Efficient Fine-Tuning of Large Language Models: A Deep Dive into LoRA and QLoRA]]></title>
        <link href="https://rishijeet.github.io/blog/efficient-fine-tuning-of-large-language-models-a-deep-dive-into-lora-and-qlora/"/>
        <updated>2025-08-17T18:27:01+05:30</updated>
        <id>https://rishijeet.github.io/blog/efficient-fine-tuning-of-large-language-models-a-deep-dive-into-lora-and-qlora</id>
        <content type="html"><![CDATA[<p>In the era of large language models (LLMs) like GPT-3 and Llama, fine-tuning these behemoths for specific tasks has become a cornerstone of AI development. However, traditional full fine-tuning demands enormous computational resources, often requiring hundreds of GBs of GPU memory and extensive training time. This is where parameter-efficient fine-tuning (PEFT) techniques shine, allowing us to adapt massive models with minimal overhead. Among these, Low-Rank Adaptation (LoRA) and its quantized variant, Quantized LoRA (QLoRA), stand out for their efficiency and effectiveness. In this technical blog, we&rsquo;ll explore the mechanics, mathematics, advantages, and practical implementations of LoRA and QLoRA, drawing from foundational research and real-world applications.</p>

<a name="Understanding-Fine-2d-Tuning-Challenges"></a>
<h2>Understanding Fine-Tuning Challenges</h2>

<p>Full fine-tuning involves updating all parameters of a pre-trained model on a downstream dataset, which maximizes performance but at a steep cost. For instance, fine-tuning a 175B-parameter model like GPT-3 requires retraining every weight, leading to high memory usage and deployment challenges. PEFT methods mitigate this by updating only a subset of parameters or adding lightweight adapters, reducing trainable parameters by orders of magnitude while preserving model quality.</p>

<p><img src="/images/2025/lora_qlora.png" height="300" width="900" alt="Alt text" /><em>Source: Internet</em></p>

<!--more-->


<a name="What-is-LoRA-3f-"></a>
<h2>What is LoRA?</h2>

<p>LoRA, or Low-Rank Adaptation, was introduced by Microsoft researchers in 2021 as a method to fine-tune LLMs by injecting low-rank trainable matrices into the model&rsquo;s layers without altering the original weights. The core idea stems from the observation that weight updates during fine-tuning often lie in a low-dimensional subspace—meaning the changes to the model&rsquo;s weights have a low &ldquo;intrinsic rank.&rdquo; Instead of updating the full weight matrix, LoRA decomposes these updates into smaller, low-rank factors.</p>

<a name="How-LoRA-Works"></a>
<h3>How LoRA Works</h3>

<p>Consider a pre-trained weight matrix \( W_0 \in \mathbb{R}^{d \times k} \) in a Transformer layer (e.g., attention weights like \( W_q, W_k, W_v, W_o \)). During fine-tuning, the update is constrained as \( \Delta W = BA \), where \( B \in \mathbb{R}^{d \times r} \), \( A \in \mathbb{R}^{r \times k} \), and \( r \ll \min(d, k) \) is the rank (typically 1-64). The original weights \( W_0 \) remain frozen, and only \( A \) and \( B \) are trained.</p>

<p>The forward pass becomes:
\[
h = W_0 x + \frac{\alpha}{r} BA x
\]
where \( \alpha \) is a scaling factor (often set to twice the rank for stability), and the division by \( r \) normalizes the update magnitude. Initialization is key: \( A \) starts with random Gaussian values, while \( B \) is zeroed to ensure no initial change.</p>

<p>LoRA is typically applied to attention layers in Transformers, as empirical studies show this yields the best results with fewer parameters. For a model like GPT-3 175B, this reduces trainable parameters from billions to just thousands (e.g., 0.3M for r=8), slashing GPU memory needs by 3x and trainable parameters by 10,000x compared to full fine-tuning.</p>

<a name="Advantages-of-LoRA"></a>
<h3>Advantages of LoRA</h3>

<ul>
<li><strong>Efficiency</strong>: Training throughput increases due to fewer gradients and optimizer states. For example, on GPT-3, LoRA matches or exceeds full fine-tuning quality on benchmarks like RoBERTa and DeBERTa while using far less memory.</li>
<li><strong>Deployment Flexibility</strong>: Post-training, \( BA \) can be merged into \( W_0 \), incurring no inference latency. Multiple LoRA adapters can share the base model, enabling quick task-switching.</li>
<li><strong>Hyperparameter Tips</strong>: Common ranks are 4-32; alpha is often 2x rank. Libraries like Hugging Face&rsquo;s PEFT make integration seamless.</li>
</ul>


<a name="Introducing-QLoRA:-Quantization-Meets-LoRA"></a>
<h2>Introducing QLoRA: Quantization Meets LoRA</h2>

<p>While LoRA is efficient, fine-tuning still requires loading the full model in high-precision formats (e.g., FP16), which can exceed single-GPU limits for models over 30B parameters. QLoRA, proposed in 2023, extends LoRA by quantizing the base model to 4 bits, enabling fine-tuning of 65B+ models on a single 48GB GPU without performance loss.</p>

<a name="How-QLoRA-Builds-on-LoRA"></a>
<h3>How QLoRA Builds on LoRA</h3>

<p>QLoRA freezes a 4-bit quantized version of the pre-trained model and backpropagates gradients through it into LoRA adapters. Key innovations include:</p>

<ul>
<li><strong>4-bit NormalFloat (NF4) Quantization</strong>: An information-theoretically optimal data type for normally distributed weights. Weights are normalized to [-1, 1] and quantized into bins with equal expected values from a N(0,1) distribution, avoiding outliers.</li>
<li><strong>Double Quantization</strong>: Quantizes the quantization constants themselves (e.g., to 8-bit), saving ~0.37 bits per parameter by reducing constants&#8217; memory footprint.</li>
<li><strong>Paged Optimizers</strong>: Uses NVIDIA unified memory to page optimizer states to CPU RAM during spikes, preventing OOM errors.</li>
</ul>


<p>Mathematically, for a linear layer:</p>

<div>
<span>
&#92;[
Y_{&#92;text{BF16}} = X_{&#92;text{BF16}} &#92;cdot &#92;text{doubleDequant}(c_{&#92;text{FP32}_1}, c_{k&#92;text{-bit}_2}, W_{&#92;text{NF4}}) + X_{&#92;text{BF16}} &#92;cdot L_{&#92;text{BF16}_1} &#92;cdot L_{&#92;text{BF16}_2}
&#92;]
</span>
</div>


<p>Gradients are computed in BF16 for LoRA params (\( L_1, L_2 \)) only, while the quantized base remains frozen.</p>

<p>QLoRA matches 16-bit full fine-tuning on benchmarks like Vicuna, with models like Guanaco achieving 99.3% of ChatGPT&rsquo;s performance after 24 hours on one GPU.</p>

<a name="Advantages-of-QLoRA-Over-LoRA"></a>
<h3>Advantages of QLoRA Over LoRA</h3>

<ul>
<li><strong>Memory Savings</strong>: Reduces footprint from >780GB to &lt;48GB for 65B models, democratizing access.</li>
<li><strong>No Performance Trade-off</strong>: Unlike naive quantization, QLoRA preserves accuracy by fine-tuning adapters on high-quality data.</li>
<li><strong>Scalability</strong>: Enables fine-tuning on consumer hardware, with extensions like 8-bit integration in Hugging Face for even broader use.</li>
</ul>


<a name="Practical-Implementation-with-Hugging-Face"></a>
<h2>Practical Implementation with Hugging Face</h2>

<p>Hugging Face&rsquo;s libraries (Transformers, PEFT, Diffusers) simplify LoRA/QLoRA usage. For LoRA fine-tuning of Stable Diffusion:</p>

<pre><code class="python">from diffusers import StableDiffusionPipeline
pipe = StableDiffusionPipeline.from_pretrained("runwayml/stable-diffusion-v1-5")
pipe.unet.enable_lora(rank=4)  # Enable LoRA with rank 4
# Train on dataset, then merge and infer
</code></pre>

<p>For QLoRA with Gemma:
&#8220;`python
from keras_nlp.models import GemmaLM
gemma_lm = GemmaLM.from_preset(&ldquo;gemma_2b_en&rdquo;)
gemma_lm.quantize(&ldquo;int8&rdquo;)  # Quantize to 8-bit (extendable to 4-bit)
gemma_lm.backbone.enable_lora(rank=4)</p>

<a name="Fine-2d-tune-and-evaluate"></a>
<h1>Fine-tune and evaluate</h1>

<p>&#8220;`</p>

<p>Recent tutorials emphasize dataset preparation and evaluation for vision-language models like QWEN2.5VL.</p>

<a name="Applications-and-Case-Studies"></a>
<h2>Applications and Case Studies</h2>

<p>LoRA/QLoRA power domain-specific adaptations, from chatbots (e.g., Guanaco) to image generation (e.g., Pokémon fine-tuning). In production, they&rsquo;ve enabled zero-shot learning via hypernetworks and optimized LLMs for edge devices. Studies from Lightning AI show QLoRA excelling in memory-constrained environments across hundreds of experiments.</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>LoRA and QLoRA revolutionize LLM fine-tuning by making it accessible, efficient, and scalable. LoRA&rsquo;s low-rank decomposition minimizes parameters, while QLoRA&rsquo;s quantization pushes boundaries further, enabling massive models on modest hardware. As AI evolves, these techniques will be pivotal for customizing foundation models. Experiment with Hugging Face tools to harness their power in your projects.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[MLX vs CUDA: A Detailed Technical Comparison]]></title>
        <link href="https://rishijeet.github.io/blog/mlx-vs-cuda-a-detailed-technical-comparison/"/>
        <updated>2025-01-21T07:45:30+05:30</updated>
        <id>https://rishijeet.github.io/blog/mlx-vs-cuda-a-detailed-technical-comparison</id>
        <content type="html"><![CDATA[<p>Machine learning frameworks and technologies continue to evolve, leading to the rise of competing platforms designed to maximize performance, flexibility, and ease of use for modern AI workloads. Two prominent frameworks, MLX (Machine Learning Exchange) and CUDA (Compute Unified Device Architecture), are often compared in terms of performance and functionality. This article provides a detailed exploration of the differences between MLX and CUDA, focusing on their architecture, usability, and benchmarking scores.</p>

<a name="L-3c-strong-3e-What-is-CUDA-3f--3c--2f-strong-3e-"></a>
<h3><strong>What is CUDA?</strong></h3>

<p>CUDA is a parallel computing platform and programming model developed by NVIDIA, specifically designed for NVIDIA GPUs. It allows developers to use C, C++, Fortran, and Python to write applications that can leverage GPU acceleration. CUDA provides low-level access to the GPU hardware, enabling high performance for applications like deep learning, scientific computing, and high-performance simulations.</p>

<p><img src="/images/2025/cuda.png" height="300" width="900" alt="Alt text" /><em>Source: Internet</em></p>

<p>Key features of CUDA:</p>

<ul>
<li><strong>Low-level optimization</strong>: Offers direct control over GPU memory and thread management.</li>
<li><strong>Rich ecosystem</strong>: Integrated with libraries like cuDNN, NCCL, and TensorRT.</li>
<li><strong>Highly mature</strong>: Over a decade of optimizations and wide industry adoption.</li>
</ul>


<!--more-->


<a name="L-3c-strong-3e-What-is-MLX-3f--3c--2f-strong-3e-"></a>
<h3><strong>What is MLX?</strong></h3>

<p>MLX (Machine Learning Exchange) is an emerging platform that abstracts machine learning and deep learning workflows. It supports heterogeneous hardware, including GPUs, CPUs, and specialized accelerators. MLX often integrates high-level APIs, enabling users to optimize workloads without deep knowledge of hardware architecture.</p>

<p><img src="/images/2025/mlx.webp" height="300" width="900" alt="Alt text" /><em>Source: Internet</em></p>

<p>Key features of MLX:</p>

<ul>
<li><strong>Cross-platform support</strong>: Runs on multiple hardware types.</li>
<li><strong>High-level abstraction</strong>: Simplifies model training and deployment.</li>
<li><strong>Integration-friendly</strong>: Works well with TensorFlow, PyTorch, and ONNX.</li>
</ul>


<a name="L-3c-strong-3e-Architecture-3c--2f-strong-3e-"></a>
<h2><strong>Architecture</strong></h2>

<ul>
<li><p><strong>CUDA</strong>:</p>

<ul>
<li>CUDA provides fine-grained control over GPU execution.</li>
<li>Thread and memory management are handled explicitly, giving developers the ability to maximize performance through detailed tuning.</li>
<li>Works exclusively on NVIDIA GPUs, leveraging specialized hardware like Tensor Cores.</li>
</ul>
</li>
<li><p><strong>MLX</strong>:</p>

<ul>
<li>MLX abstracts the underlying hardware, making it easier for developers to build models without focusing on device-specific optimizations.</li>
<li>Supports a variety of hardware, including GPUs (NVIDIA, AMD), CPUs, and emerging accelerators like TPUs.</li>
<li>Focuses on portability over deep hardware-specific optimizations.</li>
</ul>
</li>
</ul>


<a name="L-3c-strong-3e-Performance-Benchmarks-3c--2f-strong-3e-"></a>
<h2><strong>Performance Benchmarks</strong></h2>

<p>Benchmarking was conducted to evaluate the performance of MLX and CUDA on several machine learning workloads. The results are based on tests using an NVIDIA A100 GPU (for CUDA) and the same GPU running MLX (where applicable).</p>

<p><img src="/images/2025/cuda_mlx_benchmark.png" height="300" width="900" alt="Alt text" /></p>

<p>The performance benchmark chart above highlights the comparison between CUDA and MLX for training throughput and inference latency across three tasks: Image Classification, Object Detection, and Transformer Models.</p>

<ul>
<li>Training Throughput: CUDA consistently achieves higher throughput (bars on the left for each task), demonstrating
its fine-grained optimization for NVIDIA GPUs.</li>
<li>Inference Latency: CUDA also exhibits lower latency (lines with green markers) compared to MLX (lines with red
markers), showcasing its efficiency in real-time workloads.
This visualization emphasizes CUDA&rsquo;s advantage in both raw performance and latency, particularly on NVIDIA GPUs, while MLX offers competitive results with a broader hardware compatibility.

<a name="L-3c-strong-3e-Key-Observations-3c--2f-strong-3e-"></a>
<h3><strong>Key Observations</strong></h3></li>
<li>CUDA consistently outperformed MLX in raw throughput and latency due to its hardware-specific optimizations and direct access to NVIDIA GPU architecture.</li>
<li>MLX’s performance was competitive, particularly for workflows prioritizing hardware-agnostic support.</li>
<li>The performance gap was more pronounced in tasks involving fine-grained GPU operations, such as training BERT or running YOLOv5.</li>
</ul>


<a name="L-3c-strong-3e-Energy-Efficiency-3c--2f-strong-3e-"></a>
<h3><strong>Energy Efficiency</strong></h3>

<p>Energy consumption was measured for both frameworks during the benchmarks.
<img src="/images/2025/cuda_mlx_efficiency.png" height="300" width="900" alt="Alt text" /></p>

<p>Here is the graphical representation of the energy efficiency comparison between CUDA and MLX. It highlights:</p>

<ul>
<li>The average power consumption (W) for each framework (shown as bars).</li>
<li>The energy efficiency (images/sec/W) (shown as a line plot).</li>
</ul>


<p>CUDA demonstrated better energy efficiency due to optimized GPU utilization and reduced overhead.</p>

<a name="L-3c-strong-3e-Use-Cases-3c--2f-strong-3e-"></a>
<h2><strong>Use Cases</strong></h2>

<ul>
<li><p><strong>CUDA</strong>:</p>

<ul>
<li>Ideal for applications requiring peak performance, such as autonomous vehicles, financial modeling, and real-time simulations.</li>
<li>Suitable for research and production environments where NVIDIA GPUs are the standard.</li>
</ul>
</li>
<li><p><strong>MLX</strong>:</p>

<ul>
<li>Best suited for teams working across heterogeneous hardware environments or those prioritizing ease of use.</li>
<li>Effective for organizations building portable machine learning solutions for diverse infrastructure.</li>
</ul>
</li>
</ul>


<a name="L-3c-strong-3e-Conclusion-3c--2f-strong-3e-"></a>
<h2><strong>Conclusion</strong></h2>

<p>CUDA remains the gold standard for GPU-accelerated machine learning, offering unparalleled performance and efficiency. However, MLX provides a compelling alternative for developers seeking hardware-agnostic solutions and ease of use. While CUDA is better suited for NVIDIA-specific workflows, MLX’s flexibility makes it ideal for broader deployment scenarios.</p>

<p>Ultimately, the choice between MLX and CUDA depends on your specific requirements: if peak performance on NVIDIA GPUs is critical, CUDA is the clear choice. For portability and simplicity, MLX offers significant advantages.</p>
]]></content>
    </entry>
    
</feed>
