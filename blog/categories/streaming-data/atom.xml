<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[Category: streaming-data | Rishijeet Mishra]]></title>
    <link href="https://rishijeet.github.io/blog/categories/streaming-data/atom.xml" rel="self"/>
    <link href="https://rishijeet.github.io/"/>
    <updated>2024-07-03T10:56:57+05:30</updated>
    <id>https://rishijeet.github.io/</id>
    <author>
        <name><![CDATA[Rishijeet Mishra]]></name>
        <email><![CDATA[rishijeet@gmail.com]]></email>
      </author>
    <generator uri="http://octopress.org/">Octopress</generator>

    
    <entry>
        <title type="html"><![CDATA[Advantages of Enable Checkpointing in Apache Flink]]></title>
        <link href="https://rishijeet.github.io/blog/advantages-of-enable-checkpointing-in-apache-flink/"/>
        <updated>2024-05-19T21:32:50+05:30</updated>
        <id>https://rishijeet.github.io/blog/advantages-of-enable-checkpointing-in-apache-flink</id>
        <content type="html"><![CDATA[<p>Enabling checkpointing in Apache Flink provides significant advantages for ensuring the reliability, consistency, and fault-tolerance of stream processing applications. Below, I detail the benefits and provide a code example.</p>

<a name="Advantages-of-Checkpointing"></a>
<h2>Advantages of Checkpointing</h2>

<ul>
<li><p><strong>Fault Tolerance</strong> Checkpointing ensures that the state of your Flink application can be recovered in case of a failure. Flink periodically saves snapshots of the entire distributed data stream and state to a persistent storage. If a failure occurs, Flink can restart the application and restore the state from the latest checkpoint, minimizing data loss and downtime.</p></li>
<li><p><strong>Exactly-Once Processing Semantics</strong> With checkpointing, Flink guarantees exactly-once processing semantics. This means that each event in the stream is processed exactly once, even in the face of failures. This is crucial for applications where accuracy is paramount, such as financial transaction processing or data analytics.</p></li>
<li><p><strong>Consistent State Management</strong> Checkpointing provides consistent snapshots of the application state. This consistency ensures that all parts of the state are in sync and correspond to the same point in the input stream, avoiding issues like partial updates or inconsistent results.</p></li>
<li><p><strong>Efficient State Recovery</strong> Checkpointing allows efficient recovery of the application state. Instead of reprocessing the entire data stream from the beginning, Flink can resume processing from the last checkpoint, saving computational resources and reducing recovery time.</p></li>
<li><p><strong>Backpressure Handling</strong> Flink’s checkpointing mechanism can help manage backpressure in the system by ensuring that the system processes data at a rate that matches the checkpointing intervals, preventing data overloads.</p></li>
<li><p><strong>State Evolution</strong> Checkpointing supports state evolution, allowing updates to the state schema without losing data. This is useful for applications that need to update their state representation over time while maintaining historical consistency.</p></li>
</ul>


<!--more-->


<a name="Code-Example"></a>
<h2>Code Example</h2>

<p>Here’s a basic example of enabling checkpointing in a Flink job:</p>

<pre><code class="java">import org.apache.flink.api.common.restartstrategy.RestartStrategies;
import org.apache.flink.streaming.api.environment.CheckpointConfig;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.CheckpointingMode;

public class CheckpointingExample {

    public static void main(String[] args) throws Exception {
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // Enable checkpointing every 10 seconds
        env.enableCheckpointing(10000); // 10 seconds

        // Set checkpointing mode to exactly-once (default)
        env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);

        // Ensure 500 ms of progress happen between checkpoints
        env.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);

        // Checkpoints have to complete within one minute, or are discarded
        env.getCheckpointConfig().setCheckpointTimeout(60000);

        // Allow only one checkpoint to be in progress at the same time
        env.getCheckpointConfig().setMaxConcurrentCheckpoints(1);

        // Retain the checkpoints on cancellation
        env.getCheckpointConfig().enableExternalizedCheckpoints(CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);

        // Set a restart strategy
        env.setRestartStrategy(RestartStrategies.fixedDelayRestart(
            3, // number of restart attempts
            10000 // delay between attempts
        ));

        // Define your data source, transformations, and sinks
        // ...

        env.execute("Flink Checkpointing Example");
    }
}
</code></pre>

<p>By setting up checkpointing, you ensure your Flink application is resilient and can recover from failures efficiently, maintaining data integrity and consistency.</p>

<p>For more detailed information, you can refer to the <a href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/fault-tolerance/checkpointing/">Apache Flink Documentation on Checkpointing</a>.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Understanding Windowing in Apache Flink]]></title>
        <link href="https://rishijeet.github.io/blog/understanding-windowing-in-apache-flink/"/>
        <updated>2024-05-19T20:57:38+05:30</updated>
        <id>https://rishijeet.github.io/blog/understanding-windowing-in-apache-flink</id>
        <content type="html"><![CDATA[<p>Windowing is a fundamental concept in stream processing that allows you to group a continuous stream of events into finite chunks for processing. Apache Flink provides powerful windowing capabilities that support various window types and triggers for flexible, real-time data analysis.</p>

<p><img src="/images/windows.svg" height="300" width="900" alt="Alt text" /><em>Source: Apache Flink</em></p>

<a name="Types-of-Windows-in-Flink"></a>
<h2>Types of Windows in Flink</h2>

<a name="Tumbling-Windows"></a>
<h3>Tumbling Windows</h3>

<p>Tumbling windows are fixed-size, non-overlapping windows. Each event belongs to exactly one window.</p>

<pre><code class="java">DataStream&lt;Event&gt; stream = ...; // your event stream
DataStream&lt;WindowedEvent&gt; windowedStream = stream
    .keyBy(event -&gt; event.getKey())
    .window(TumblingEventTimeWindows.of(Time.seconds(10)))
    .apply(new WindowFunction&lt;Event, WindowedEvent, Key, TimeWindow&gt;() {
        @Override
        public void apply(Key key, TimeWindow window, Iterable&lt;Event&gt; input, Collector&lt;WindowedEvent&gt; out) {
            // Window processing logic
        }
    });
</code></pre>

<a name="Sliding-Windows"></a>
<h3>Sliding Windows</h3>

<p>Sliding windows are also fixed-size but can overlap. Each event can belong to multiple windows depending on the slide interval.</p>

<pre><code class="java">DataStream&lt;Event&gt; stream = ...;
DataStream&lt;WindowedEvent&gt; windowedStream = stream
    .keyBy(event -&gt; event.getKey())
    .window(SlidingEventTimeWindows.of(Time.seconds(10), Time.seconds(5)))
    .apply(new WindowFunction&lt;Event, WindowedEvent, Key, TimeWindow&gt;() {
        @Override
        public void apply(Key key, TimeWindow window, Iterable&lt;Event&gt; input, Collector&lt;WindowedEvent&gt; out) {
            // Window processing logic
        }
    });
</code></pre>



<!--more-->


<a name="Session-Windows"></a>
<h3>Session Windows</h3>

<p>Session windows group events that arrive close to each other, with a session gap defining the threshold for grouping.</p>

<pre><code class="java">DataStream&lt;Event&gt; stream = ...;
DataStream&lt;WindowedEvent&gt; windowedStream = stream
    .keyBy(event -&gt; event.getKey())
    .window(ProcessingTimeSessionWindows.withGap(Time.minutes(5)))
    .apply(new WindowFunction&lt;Event, WindowedEvent, Key, TimeWindow&gt;() {
        @Override
        public void apply(Key key, TimeWindow window, Iterable&lt;Event&gt; input, Collector&lt;WindowedEvent&gt; out) {
            // Window processing logic
        }
    });
</code></pre>

<a name="Global-Windows"></a>
<h3>Global Windows</h3>

<p>Global windows group all elements with the same key into a single window. These windows require custom triggers to define when to produce results.</p>

<pre><code class="java">DataStream&lt;Event&gt; stream = ...;
DataStream&lt;WindowedEvent&gt; windowedStream = stream
    .keyBy(event -&gt; event.getKey())
    .window(GlobalWindows.create())
    .trigger(CountTrigger.of(100)) // Triggering every 100 events
    .apply(new WindowFunction&lt;Event, WindowedEvent, Key, TimeWindow&gt;() {
        @Override
        public void apply(Key key, TimeWindow window, Iterable&lt;Event&gt; input, Collector&lt;WindowedEvent&gt; out) {
            // Window processing logic
        }
    });
</code></pre>

<a name="Assigning-Timestamps-and-Generating-Watermarks"></a>
<h2>Assigning Timestamps and Generating Watermarks</h2>

<p>For event-time windowing, it&rsquo;s crucial to assign timestamps to events and generate watermarks.</p>

<pre><code class="java">DataStream&lt;Event&gt; stream = ...;
WatermarkStrategy&lt;Event&gt; watermarkStrategy = WatermarkStrategy
    .&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(5))
    .withTimestampAssigner(new SerializableTimestampAssigner&lt;Event&gt;() {
        @Override
        public long extractTimestamp(Event event, long recordTimestamp) {
            return event.getTimestamp();
        }
    });

DataStream&lt;Event&gt; timestampedStream = stream.assignTimestampsAndWatermarks(watermarkStrategy);
</code></pre>

<a name="Example:-Tumbling-Window-with-Event-Time"></a>
<h2>Example: Tumbling Window with Event Time</h2>

<pre><code class="java">import org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.Collector;

public class TumblingWindowExample {
    public static void main(String[] args) throws Exception {
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        DataStream&lt;Event&gt; stream = env.addSource(new EventSource());

        WatermarkStrategy&lt;Event&gt; watermarkStrategy = WatermarkStrategy
            .&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(5))
            .withTimestampAssigner(new SerializableTimestampAssigner&lt;Event&gt;() {
                @Override
                public long extractTimestamp(Event event, long recordTimestamp) {
                    return event.getTimestamp();
                }
            });

        DataStream&lt;Event&gt; timestampedStream = stream.assignTimestampsAndWatermarks(watermarkStrategy);

        timestampedStream
            .keyBy(event -&gt; event.getKey())
            .window(TumblingEventTimeWindows.of(Time.seconds(10)))
            .apply(new WindowFunction&lt;Event, WindowedEvent, String, TimeWindow&gt;() {
                @Override
                public void apply(String key, TimeWindow window, Iterable&lt;Event&gt; input, Collector&lt;WindowedEvent&gt; out) {
                    // Window processing logic
                    out.collect(new WindowedEvent(key, window, input));
                }
            })
            .print();

        env.execute("Tumbling Window Example");
    }
}
</code></pre>

<a name="Benefits-of-Windowing"></a>
<h2>Benefits of Windowing</h2>

<p><strong>Temporal Aggregation</strong>: Windows allow you to perform aggregations and computations over specific time intervals, essential for real-time analytics and monitoring.</p>

<p><strong>Handling Out-of-Order Events</strong>: With proper windowing and watermarking, Flink can handle out-of-order events and ensure accurate results.</p>

<p><strong>Scalability</strong>: Windowed operations can be distributed and parallelized, making it feasible to process large-scale data streams efficiently.</p>

<p><strong>Flexibility</strong>: Flink&rsquo;s windowing system is highly flexible, supporting various window types and custom triggers, catering to a wide range of use cases.</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>Windowing in Apache Flink is a versatile and powerful feature that enables the processing of continuous data streams in meaningful chunks. By utilizing different types of windows and configuring them appropriately, you can implement robust real-time data processing pipelines that handle time-based computations effectively.</p>

<p>For more detailed information, you can refer to the <a href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/">Apache Flink Documentation on Windowing</a> and <a href="/blog/understanding-event-time-in-apache-flink">Understanding Event Time in Apache Flink</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Understanding Watermarks in Apache Flink]]></title>
        <link href="https://rishijeet.github.io/blog/understanding-watermarks-in-apache-flink/"/>
        <updated>2024-05-19T20:35:48+05:30</updated>
        <id>https://rishijeet.github.io/blog/understanding-watermarks-in-apache-flink</id>
        <content type="html"><![CDATA[<a name="What-are-Watermarks-3f-"></a>
<h2>What are Watermarks?</h2>

<p>Watermarks in Apache Flink are a mechanism to handle event time and out-of-order events in stream processing. They represent a point in time in the data stream and indicate that no events with timestamps earlier than the watermark should be expected. Essentially, watermarks help Flink understand the progress of event time in the stream and trigger computations like window operations based on this understanding.</p>

<ul>
<li><strong>Event Time</strong> Event Time is the time at which events actually occurred, as recorded in the event data itself. For more detailed information, you can refer to the <a href="/blog/understanding-event-time-in-apache-flink">Understanding Event Time in Apache Flink</a></li>
<li><strong>Ingestion Time</strong> Ingestion Time is the time when events enter the Flink pipeline.</li>
<li><strong>Processing Time</strong> Processing Time is the time when events are processed by Flink.</li>
</ul>


<a name="Watermarks"></a>
<h3>Watermarks</h3>

<ul>
<li><strong>Definition</strong>: A watermark is a timestamp that flows as part of the data stream and denotes the progress of event time.</li>
<li><strong>Purpose</strong>: Watermarks help in handling late events and triggering event-time-based operations like windowing.</li>
</ul>


<p><img src="/images/stream_watermark_in_order.svg" height="300" width="900" alt="Alt text" /><em>Source: Apache Flink</em></p>

<p><img src="/images/stream_watermark_out_of_order.svg" height="300" width="900" alt="Alt text" /><em>Source: Apache Flink</em></p>

<!--more-->


<a name="Generating-Watermarks"></a>
<h2>Generating Watermarks</h2>

<p>Watermarks can be generated in two main ways:</p>

<p><strong>Punctuated Watermarks</strong>: These are emitted at specific points in the stream, often when certain events are encountered.</p>

<p><strong>Periodic Watermarks</strong>: These are emitted at regular intervals.</p>

<a name="Example-of-Watermark-Generation"></a>
<h3>Example of Watermark Generation</h3>

<p>Here’s a code example demonstrating how to assign timestamps and generate watermarks using periodic watermarks:</p>

<pre><code class="java">import org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;
import org.apache.flink.api.common.eventtime.WatermarkGenerator;
import org.apache.flink.api.common.eventtime.WatermarkGeneratorSupplier;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.streaming.api.watermark.Watermark;

public class WatermarkExample {

    public static void main(String[] args) throws Exception {
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        DataStream&lt;Event&gt; stream = env.addSource(new EventSource());

        WatermarkStrategy&lt;Event&gt; watermarkStrategy = WatermarkStrategy
            .&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(5))
            .withTimestampAssigner(new SerializableTimestampAssigner&lt;Event&gt;() {
                @Override
                public long extractTimestamp(Event event, long recordTimestamp) {
                    return event.getTimestamp();
                }
            });

        DataStream&lt;Event&gt; watermarkedStream = stream.assignTimestampsAndWatermarks(watermarkStrategy);

        watermarkedStream
            .keyBy(event -&gt; event.getKey())
            .window(TumblingEventTimeWindows.of(Time.seconds(10)))
            .process(new EventTimeWindowFunction())
            .print();

        env.execute("Watermark Example");
    }
}
</code></pre>

<a name="Example-Source-Function"></a>
<h3>Example Source Function</h3>

<p>Here’s a simple source function generating events with timestamps:</p>

<pre><code class="java">public class EventSource implements SourceFunction&lt;Event&gt; {
    private volatile boolean running = true;

    @Override
    public void run(SourceContext&lt;Event&gt; ctx) throws Exception {
        while (running) {
            long timestamp = System.currentTimeMillis();
            ctx.collectWithTimestamp(new Event("key", timestamp), timestamp);
            ctx.emitWatermark(new Watermark(timestamp - 5000));
            Thread.sleep(100);
        }
    }

    @Override
    public void cancel() {
        running = false;
    }
}
</code></pre>

<a name="Handling-Parallel-Streams"></a>
<h2>Handling Parallel Streams</h2>

<p>In a distributed environment, Flink processes streams in parallel. Each parallel sub-task can emit its own watermarks. Flink uses the minimum watermark of all parallel sub-tasks to ensure that no events are missed.</p>

<p><img src="/images/parallel_streams_watermarks.svg" height="300" width="900" alt="Alt text" /><em>Source: Apache Flink</em></p>

<a name="Example-of-Parallel-Watermark-Handling"></a>
<h3>Example of Parallel Watermark Handling</h3>

<p>When using parallel streams, each sub-task generates its watermarks, and Flink computes the minimum watermark across all sub-tasks. This is crucial to correctly handle late events and ensure accurate window computations.</p>

<pre><code class="java">DataStream&lt;Event&gt; stream = env.addSource(new ParallelEventSource()).setParallelism(4);

WatermarkStrategy&lt;Event&gt; watermarkStrategy = WatermarkStrategy
    .&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(5))
    .withTimestampAssigner(new SerializableTimestampAssigner&lt;Event&gt;() {
        @Override
        public long extractTimestamp(Event event, long recordTimestamp) {
            return event.getTimestamp();
        }
    });

DataStream&lt;Event&gt; watermarkedStream = stream.assignTimestampsAndWatermarks(watermarkStrategy);

watermarkedStream
    .keyBy(event -&gt; event.getKey())
    .window(TumblingEventTimeWindows.of(Time.seconds(10)))
    .process(new EventTimeWindowFunction())
    .print();
</code></pre>

<a name="Watermark-Strategy-for-Parallel-Sources"></a>
<h3>Watermark Strategy for Parallel Sources</h3>

<p>Here&rsquo;s an example of a parallel source function generating events and watermarks:</p>

<pre><code class="java">public class ParallelEventSource extends RichParallelSourceFunction&lt;Event&gt; {
    private volatile boolean running = true;

    @Override
    public void run(SourceContext&lt;Event&gt; ctx) throws Exception {
        while (running) {
            long timestamp = System.currentTimeMillis();
            ctx.collectWithTimestamp(new Event("key", timestamp), timestamp);
            ctx.emitWatermark(new Watermark(timestamp - 5000));
            Thread.sleep(100);
        }
    }

    @Override
    public void cancel() {
        running = false;
    }
}
</code></pre>

<a name="Benefits-of-Watermarks"></a>
<h2>Benefits of Watermarks</h2>

<p> <strong>Handling Late Data</strong>: Watermarks allow the system to process late events and include them in the correct windows, ensuring completeness and accuracy.</p>

<p><strong>Event Time Processing</strong>: With watermarks, Flink can process events based on their actual occurrence time, making it suitable for applications where timing is critical.</p>

<p><strong>Out-of-Order Event Handling</strong>: Watermarks enable Flink to handle out-of-order events gracefully by providing a tolerance for lateness.</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>Watermarks are a critical component in Apache Flink for dealing with event time and out-of-order data. By generating and using watermarks, Flink can accurately perform time-based computations like windowing and aggregations, even in the presence of late-arriving events. This makes Flink a powerful tool for real-time stream processing applications.</p>

<p>For more detailed information, you can refer to the <a href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/event_time/">Apache Flink Documentation on Watermarks</a> and <a href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/concepts/time/">Event Time</a>.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Understanding Event Time in Apache Flink]]></title>
        <link href="https://rishijeet.github.io/blog/understanding-event-time-in-apache-flink/"/>
        <updated>2024-05-19T20:22:47+05:30</updated>
        <id>https://rishijeet.github.io/blog/understanding-event-time-in-apache-flink</id>
        <content type="html"><![CDATA[<a name="What-is-Event-Time-3f-"></a>
<h3>What is Event Time?</h3>

<p>Event Time is one of the three time semantics in Apache Flink, along with Ingestion Time and Processing Time. Event Time refers to the time at which each individual event actually occurred, typically extracted from the event itself. This contrasts with Processing Time, which refers to the time at which events are processed by the Flink system, and Ingestion Time, which is the time at which events enter the Flink pipeline.</p>

<p><img src="/images/event_processing_time.svg" height="300" width="900" alt="Alt text" /><em>Source: Apache Flink</em></p>

<a name="Key-Features-of-Event-Time:"></a>
<h3>Key Features of Event Time:</h3>

<p><strong>Timestamp Extraction</strong>: In Event Time, each event must have a timestamp that indicates when the event occurred. This timestamp is extracted from the event data itself.</p>

<p><strong>Watermarks</strong>: Watermarks are a mechanism used to track progress in Event Time. They are special timestamps that indicate that no events with a timestamp older than the watermark should be expected. Watermarks allow Flink to handle late-arriving data and trigger computations when it is safe to assume all relevant data has been processed. For more detailed information, you can refer to the <a href="/blog/understanding-watermarks-in-apache-flink">Understanding Watermarks in Apache Flink</a></p>

<p><strong>Windowing</strong>: Event Time is crucial for windowed operations. Windows (e.g., tumbling, sliding, session windows) in Flink can be defined based on Event Time, ensuring that events are grouped according to when they actually occurred.</p>

<!-- more -->


<a name="Benefits-of-Using-Event-Time"></a>
<h2>Benefits of Using Event Time</h2>

<p><strong>Accuracy in Time-Based Operations</strong>:</p>

<ul>
<li> Using Event Time allows for more accurate and reliable time-based operations, such as windowed aggregations, joins, and pattern detections. This is because the operations are based on the actual occurrence time of events, rather than the time they are processed.</li>
</ul>


<p><strong>Handling Out-of-Order Events</strong>:</p>

<ul>
<li> Real-world data streams often have events that arrive out of order. With Event Time and watermarks, Flink can manage out-of-order events effectively. Watermarks help to delay processing just enough to account for late events without significant delays, ensuring completeness and correctness in the results.</li>
</ul>


<p><strong>Consistency Across Distributed Systems</strong>:</p>

<ul>
<li> In distributed systems, processing time can vary significantly across different nodes due to network latency, load balancing, and other factors. Event Time provides a consistent temporal reference across all nodes, ensuring that operations like windowing produce consistent results regardless of where or when events are processed.</li>
</ul>


<p><strong>Improved Late Data Handling</strong>:</p>

<ul>
<li> By leveraging watermarks, Flink can handle late-arriving data more gracefully. You can define how much lateness to tolerate and what actions to take for late data, allowing for flexible and robust processing pipelines that can deal with real-world stream data issues.</li>
</ul>


<a name="Extracting-Timestamps-and-Generating-Watermarks"></a>
<h3>Extracting Timestamps and Generating Watermarks</h3>

<p>To use Event Time in Flink, you typically need to:</p>

<p><strong>Assign Timestamps</strong>: Extract the event timestamps from the incoming data.</p>

<p><strong>Generate Watermarks</strong>: Define a strategy for generating watermarks that dictate the event-time progress.</p>

<p>Here’s an example in Java:</p>

<pre><code class="java">DataStream&lt;MyEvent&gt; stream = env.addSource(new MyEventSource());

stream
    .assignTimestampsAndWatermarks(new AssignerWithPunctuatedWatermarks&lt;MyEvent&gt;() {
        @Override
        public long extractTimestamp(MyEvent element, long previousElementTimestamp) {
            return element.getTimestamp(); // Extract timestamp from event
        }

        @Override
        public Watermark checkAndGetNextWatermark(MyEvent lastElement, long extractedTimestamp) {
            return new Watermark(extractedTimestamp - 1); // Generate watermark
        }
    })
    .keyBy(event -&gt; event.getKey())
    .window(TumblingEventTimeWindows.of(Time.seconds(10)))
    .apply(new WindowFunction&lt;MyEvent, ResultType, KeyType, TimeWindow&gt;() {
        @Override
        public void apply(KeyType key, TimeWindow window, Iterable&lt;MyEvent&gt; input, Collector&lt;ResultType&gt; out) {
            // Process windowed events
        }
    });
</code></pre>

<a name="Using-Event-Time-Windows"></a>
<h3>Using Event Time Windows</h3>

<p>Flink supports various types of windows based on Event Time:</p>

<ul>
<li><strong>Tumbling Windows</strong>: Fixed-size, non-overlapping windows.</li>
<li><strong>Sliding Windows</strong>: Fixed-size windows that can overlap.</li>
<li><strong>Session Windows</strong>: Variable-sized windows that group events based on session gaps.</li>
</ul>


<p>Example of a tumbling window in Event Time:</p>

<pre><code class="java">DataStream&lt;MyEvent&gt; stream = ...; // Your event stream

stream
    .keyBy(event -&gt; event.getKey())
    .window(TumblingEventTimeWindows.of(Time.seconds(10)))
    .sum("value"); // Aggregation function
</code></pre>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>Event Time in Apache Flink is essential for accurately processing and analyzing time-based event streams. By utilizing timestamps extracted from the events and managing time progress through watermarks, Flink ensures precise and consistent stream processing even in the presence of out-of-order and late-arriving events. This makes Event Time invaluable for real-world applications where timing accuracy is critical.</p>

<p>For more detailed information, you can refer to the <a href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/concepts/time/">Apache Flink Documentation on Event Time</a>.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Using Broadcast State Pattern in Flink for Fraud Detection]]></title>
        <link href="https://rishijeet.github.io/blog/using-broadcast-state-pattern-in-flink-for-fraud-detection/"/>
        <updated>2024-05-19T19:47:48+05:30</updated>
        <id>https://rishijeet.github.io/blog/using-broadcast-state-pattern-in-flink-for-fraud-detection</id>
        <content type="html"><![CDATA[<p>The Broadcast State Pattern in Apache Flink is a powerful feature for real-time stream processing, particularly useful for scenarios like fraud detection. This pattern allows you to maintain a shared state that can be updated and accessed by multiple parallel instances of a stream processing operator. Here&rsquo;s how it can be applied to fraud detection:</p>

<a name="Key-Concepts-of-the-Broadcast-State-Pattern"></a>
<h2>Key Concepts of the Broadcast State Pattern</h2>

<p><strong>Broadcast State</strong>: This is a state that is shared across all parallel instances of an operator. It is used to store information that needs to be accessible to all instances, such as configuration data or rules for fraud detection.</p>

<p><strong>Regular (Non-Broadcast) Streams</strong>: These streams carry the main data that needs to be processed, such as transaction events.</p>

<p><strong>Broadcast Streams</strong>: These streams carry the state updates, such as new fraud detection rules or updates to existing rules.</p>

<a name="Steps-to-Implement-Fraud-Detection-Using-Broadcast-State-Pattern"></a>
<h2>Steps to Implement Fraud Detection Using Broadcast State Pattern</h2>

<p><strong>Define the Broadcast State</strong>:</p>

<ul>
<li> Define the data structure that will hold the fraud detection rules.</li>
<li> For example, a map where the key is a rule identifier and the value is the rule details.</li>
</ul>


<p><strong>Create the Broadcast Stream</strong>:</p>

<ul>
<li> This stream will carry the updates to the fraud detection rules.</li>
<li> Use <code>BroadcastStream</code> to broadcast this stream to all parallel instances of the operator that processes the transactions.</li>
</ul>


<!-- more -->


<p><strong>Process the Broadcast State</strong>:</p>

<ul>
<li> Implement a <code>BroadcastProcessFunction</code> that handles both the main transaction stream and the broadcast rule updates.</li>
<li> In the <code>processBroadcastElement</code> method, update the broadcast state with new or modified rules.</li>
<li> In the <code>processElement</code> method, access the broadcast state to apply the current fraud detection rules to each transaction.</li>
</ul>


<p><strong>Apply Fraud Detection Logic</strong>:</p>

<ul>
<li> As each transaction event arrives, use the current set of fraud detection rules stored in the broadcast state to determine if the transaction is potentially fraudulent.</li>
</ul>


<a name="Example-Implementation"></a>
<h2>Example Implementation</h2>

<p>Here&rsquo;s a simplified example (I have used Java as an example but works with other programming languages too ) of how you might implement this in Flink:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Define a data structure for fraud detection rules</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">FraudDetectionRule</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">ruleId</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">ruleDetails</span><span class="o">;</span>
</span><span class='line'>    <span class="c1">// Other relevant fields and methods</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Create the main transaction stream</span>
</span><span class='line'><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Transaction</span><span class="o">&gt;</span> <span class="n">transactionStream</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">addSource</span><span class="o">(</span><span class="k">new</span> <span class="nf">TransactionSource</span><span class="o">());&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Create the broadcast stream for fraud detection rules</span>
</span><span class='line'><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">FraudDetectionRule</span><span class="o">&gt;</span> <span class="n">ruleStream</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">addSource</span><span class="o">(</span><span class="k">new</span> <span class="nf">RuleSource</span><span class="o">());&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Define the broadcast state descriptor</span>
</span><span class='line'><span class="n">MapStateDescriptor</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">FraudDetectionRule</span><span class="o">&gt;</span> <span class="n">ruleStateDescriptor</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">new</span> <span class="n">MapStateDescriptor</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;&gt;(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">FraudRules</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">FraudDetectionRule</span><span class="o">.</span><span class="na">class</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Broadcast the rule stream</span>
</span><span class='line'><span class="n">BroadcastStream</span><span class="o">&lt;</span><span class="n">FraudDetectionRule</span><span class="o">&gt;</span> <span class="n">broadcastRuleStream</span> <span class="o">=</span> <span class="n">ruleStream</span><span class="o">.</span><span class="na">broadcast</span><span class="o">(</span><span class="n">ruleStateDescriptor</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Process the streams with a BroadcastProcessFunction</span>
</span><span class='line'><span class="n">transactionStream</span>
</span><span class='line'>    <span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">broadcastRuleStream</span><span class="o">)</span>
</span><span class='line'>    <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">BroadcastProcessFunction</span><span class="o">&lt;</span><span class="n">Transaction</span><span class="o">,</span> <span class="n">FraudDetectionRule</span><span class="o">,</span> <span class="n">Alert</span><span class="o">&gt;()</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="kd">private</span> <span class="n">MapState</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">,</span> <span class="n">FraudDetectionRule</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">rulesState</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">parameters</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">rulesState</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">().</span><span class="na">getMapState</span><span class="o">(</span><span class="n">ruleStateDescriptor</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="n">Transaction</span> <span class="n">transaction</span><span class="o">,</span> <span class="n">ReadOnlyContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Alert</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// Apply the current fraud detection rules</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">FraudDetectionRule</span> <span class="n">rule</span> <span class="o">:</span> <span class="n">rulesState</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">applyRule</span><span class="o">(</span><span class="n">transaction</span><span class="o">,</span> <span class="n">rule</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="k">new</span> <span class="nf">Alert</span><span class="o">(</span><span class="n">transaction</span><span class="o">,</span> <span class="n">rule</span><span class="o">));</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processBroadcastElement</span><span class="o">(</span><span class="n">FraudDetectionRule</span> <span class="n">rule</span><span class="o">,</span> <span class="n">Context</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Alert</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// Update the broadcast state with new or modified rules</span>
</span><span class='line'>        <span class="n">rulesState</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">rule</span><span class="o">.</span><span class="na">ruleId</span><span class="o">,</span> <span class="n">rule</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">applyRule</span><span class="o">(</span><span class="n">Transaction</span> <span class="n">transaction</span><span class="o">,</span> <span class="n">FraudDetectionRule</span> <span class="n">rule</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// Implement rule logic here</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Example placeholder</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<a name="Benefits-of-Using-Broadcast-State-Pattern"></a>
<h2>Benefits of Using Broadcast State Pattern</h2>

<p> <strong>Consistency:</strong>Ensures all instances have a consistent view of the rules.</p>

<p> <strong>Scalability:</strong> Can handle high-throughput streams by distributing the workload across multiple parallel instances.</p>

<p><strong>Flexibility:</strong> Rules can be dynamically updated without stopping the stream processing.</p>

<p>By leveraging the Broadcast State Pattern, you can efficiently manage and apply real-time fraud detection rules across your entire data stream, ensuring timely and accurate detection of fraudulent activities.</p>
]]></content>
    </entry>
    
</feed>
