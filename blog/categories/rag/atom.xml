<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title><![CDATA[Category: rag | Rishijeet Mishra]]></title>
    <link href="https://rishijeet.github.io/blog/categories/rag/atom.xml" rel="self"/>
    <link href="https://rishijeet.github.io/"/>
    <updated>2025-09-07T09:41:00+05:30</updated>
    <id>https://rishijeet.github.io/</id>
    <author>
        <name><![CDATA[Rishijeet Mishra]]></name>
        <email><![CDATA[rishijeet@gmail.com]]></email>
      </author>
    <generator uri="http://octopress.org/">Octopress</generator>

    
    <entry>
        <title type="html"><![CDATA[Supercharge Reasoning in AI: Hands-On Chain of Thought Builds]]></title>
        <link href="https://rishijeet.github.io/blog/supercharge-reasoning-in-ai-hands-on-chain-of-thought-builds/"/>
        <updated>2025-08-29T13:26:07+05:30</updated>
        <id>https://rishijeet.github.io/blog/supercharge-reasoning-in-ai-hands-on-chain-of-thought-builds</id>
        <content type="html"><![CDATA[<p>Chain of Thought (CoT) is a prompting technique introduced in a 2022 paper by Google researchers (Wei et al., &ldquo;Chain-of-Thought Prompting Elicits Reasoning in Large Language Models&rdquo;). The core idea is simple: instead of asking an LLM for a direct answer, you instruct it to <strong>reason step by step</strong>. This elicits better performance on tasks requiring logic, math, commonsense, or multi-step planning.</p>

<p><img src="/images/2025/cot.webp" height="300" width="900" alt="Alt text" /><em>Source: Internet</em></p>

<p>For example:</p>

<ul>
<li><strong>Direct Prompt</strong>: &ldquo;What is 15% of 200?&rdquo;</li>
<li><strong>CoT Prompt</strong>: &ldquo;What is 15% of 200? Let&rsquo;s think step by step.&rdquo;</li>
</ul>


<p>The LLM might respond:</p>

<ul>
<li>&ldquo;Step 1: 15% means 15 per 100, so 15/100 = 0.15.</li>
<li>Step 2: Multiply by 200: 0.15 * 200 = 30. So, the answer is 30.&#8221;</li>
</ul>


<!--more-->


<p>This &ldquo;thinking&rdquo; process isn&rsquo;t magic—it&rsquo;s emergent from the model&rsquo;s training on vast datasets where step-by-step explanations are common. CoT shines in zero-shot (no examples) or few-shot (with examples) scenarios, and variants like <strong>Tree of Thoughts</strong> or <strong>Self-Consistency</strong> build on it for even more robustness.</p>

<a name="Why-Does-CoT-Work-3f-"></a>
<h3>Why Does CoT Work?</h3>

<ul>
<li><strong>Decomposes Complexity</strong>: Breaks problems into manageable sub-steps, reducing error rates.</li>
<li><strong>Transparency</strong>: Users see the &ldquo;thought process,&rdquo; building trust and allowing debugging.</li>
<li><strong>Scalability</strong>: Works with any LLM API; no need for fine-tuning.</li>
<li><strong>Applications</strong>: Math solvers, code debuggers, decision-making tools, chatbots that explain reasoning.</li>
</ul>


<p>Research shows CoT improves accuracy by 10-50% on benchmarks like GSM8K (math) or CommonsenseQA. In interactive apps, it can stream thoughts progressively, giving users a &ldquo;processing&rdquo; indicator.</p>

<a name="Evolution-and-Variants-of-CoT"></a>
<h2>Evolution and Variants of CoT</h2>

<p>CoT has evolved rapidly:</p>

<ul>
<li><strong>Zero-Shot CoT</strong>: Just add &ldquo;Let&rsquo;s think step by step&rdquo; to the prompt.</li>
<li><strong>Few-Shot CoT</strong>: Provide 2-5 examples of step-by-step reasoning before the query.</li>
<li><strong>Automatic CoT</strong>: Use LLMs to generate CoT examples dynamically.</li>
<li><strong>Tree of Thoughts (ToT)</strong>: Explores multiple reasoning paths like a tree search.</li>
<li><strong>Graph of Thoughts</strong>: Models reasoning as a graph for non-linear problems.</li>
</ul>


<p>In 2025, with models like Grok 4, CoT is often combined with tools (e.g., code execution or web search) for agentic systems—AI agents that plan, act, and reflect.</p>

<a name="Building-a-Chain-of-Thought-Application:-Step-2d-by-2d-Step-Guide"></a>
<h2>Building a Chain of Thought Application: Step-by-Step Guide</h2>

<p>To build a CoT application, we&rsquo;ll create a Python-based tool that:</p>

<ol>
<li>Takes user input.</li>
<li>Applies CoT prompting via an LLM API.</li>
<li>Streams the response to show &ldquo;thinking&rdquo; in real-time (using API streaming features).</li>
<li>Parses the final answer for clarity.</li>
</ol>


<p>We&rsquo;ll use OpenAI&rsquo;s API as an example. Assumptions:</p>

<ul>
<li>You have an API key.</li>
<li>Focus on a math/word problem solver, but extensible to any domain.</li>
</ul>


<a name="Step-1:-Set-Up-Your-Environment"></a>
<h3>Step 1: Set Up Your Environment</h3>

<p>Install required libraries:
<code>bash
pip install openai requests
</code></p>

<a name="Step-2:-Basic-CoT-Implementation"></a>
<h3>Step 2: Basic CoT Implementation</h3>

<p>Start with a simple non-streaming version. This script prompts the LLM with CoT and prints the full response.</p>

<pre><code class="python">import openai

# Set your API key
openai.api_key = "your-openai-api-key"  # Replace with actual key

def cot_reasoning(query, model="gpt-4o"):
    """
    Applies Chain of Thought prompting to a query.

    Args:
    - query (str): The user's question.
    - model (str): LLM model to use.

    Returns:
    - str: The reasoned response.
    """
    # CoT Prompt Template (Few-Shot for better results)
    prompt = """
    Solve the following problem step by step.

    Example 1:
    Question: If a car travels 60 miles in 1.5 hours, what is its speed?
    Step 1: Speed is distance divided by time.
    Step 2: Distance = 60 miles, Time = 1.5 hours.
    Step 3: Speed = 60 / 1.5 = 40 mph.
    Answer: 40 mph.

    Example 2:
    Question: What is the next number in the sequence: 2, 4, 8, 16?
    Step 1: Observe the pattern: each number is doubled.
    Step 2: 2 * 2 = 4, 4 * 2 = 8, 8 * 2 = 16.
    Step 3: Next is 16 * 2 = 32.
    Answer: 32.

    Now, your question:
    Question: {query}
    """

    formatted_prompt = prompt.format(query=query)

    response = openai.ChatCompletion.create(
        model=model,
        messages=[{"role": "user", "content": formatted_prompt}]
    )

    return response.choices[0].message.content

# Usage
query = "What is 25% of 400?"
result = cot_reasoning(query)
print(result)
</code></pre>

<p><strong>Expected Output</strong>:
<code>
Step 1: 25% means 25 per 100, so 0.25.
Step 2: Multiply by 400: 0.25 * 400 = 100.
Answer: 100.
</code></p>

<p>This shows the &ldquo;thinking&rdquo; steps. To make it interactive, add a loop for multiple queries.</p>

<a name="Step-3:-Adding-Real-2d-Time-Processing-Feedback"></a>
<h3>Step 3: Adding Real-Time Processing Feedback</h3>

<p>To &ldquo;let you know that it is processing these steps,&rdquo; use streaming. OpenAI supports response streaming, printing tokens as they arrive—simulating thinking.</p>

<p>Modify the function:</p>

<pre><code class="python">import openai
import sys

openai.api_key = "your-openai-api-key"

def cot_streaming_reasoning(query, model="gpt-4o"):
    """
    Streams Chain of Thought reasoning in real-time.
    """
    prompt = """
    Solve the following problem step by step. Think out loud.

    # Few-shot examples here (same as above)

    Question: {query}
    """
    formatted_prompt = prompt.format(query=query)

    stream = openai.ChatCompletion.create(
        model=model,
        messages=[{"role": "user", "content": formatted_prompt}],
        stream=True  # Enable streaming
    )

    print("Thinking...")
    full_response = ""
    for chunk in stream:
        if chunk.choices[0].delta.get("content"):
            content = chunk.choices[0].delta.content
            sys.stdout.write(content)  # Print incrementally
            sys.stdout.flush()
            full_response += content
    print("\nDone!")

    return full_response

# Usage
query = "If I have 3 apples and eat 2, how many are left?"
cot_streaming_reasoning(query)
</code></pre>

<p><strong>How It Works</strong>:</p>

<ul>
<li>The <code>stream=True</code> parameter yields partial responses.</li>
<li>We print each chunk, showing steps like &ldquo;Step 1: &hellip;&rdquo; as they generate.</li>
<li>This creates a &ldquo;processing&rdquo; effect—users see thoughts unfolding.</li>
</ul>


<p>For a web app, use Flask or Streamlit to stream via WebSockets.</p>

<a name="Step-4:-Advanced-Features--e2--80--93--Parsing-and-Error-Handling"></a>
<h3>Step 4: Advanced Features – Parsing and Error Handling</h3>

<p>To extract the final answer reliably, parse the response. Add self-consistency by generating multiple CoTs and voting.</p>

<pre><code class="python">def parse_final_answer(response):
    """
    Extracts the final answer from CoT response.
    """
    lines = response.split("\n")
    for line in reversed(lines):
        if line.startswith("Answer:"):
            return line.split("Answer:")[1].strip()
    return "No clear answer found."

# In your main function:
result = cot_streaming_reasoning(query)
final_answer = parse_final_answer(result)
print(f"Final Answer: {final_answer}")
</code></pre>

<p>For robustness (Self-Consistency CoT):</p>

<ul>
<li>Run 3-5 CoT generations.</li>
<li>Use majority vote on answers.</li>
</ul>


<pre><code class="python">def self_consistent_cot(query, num_samples=3):
    answers = []
    for _ in range(num_samples):
        response = cot_reasoning(query)  # Or streaming version
        answer = parse_final_answer(response)
        answers.append(answer)

    # Simple majority vote
    from collections import Counter
    most_common = Counter(answers).most_common(1)
    return most_common[0][0] if most_common else "Inconsistent results"

# Usage
consistent_answer = self_consistent_cot("A bat and ball cost $1.10 total. The bat costs $1 more than the ball. How much is the ball?")
print(consistent_answer)  # Should be $0.05
</code></pre>

<a name="Step-5:-Building-a-Full-Application"></a>
<h3>Step 5: Building a Full Application</h3>

<p>For a complete app, use Streamlit for a UI:</p>

<pre><code class="python">import streamlit as st
import openai

openai.api_key = "your-openai-api-key"

st.title("Chain of Thought Reasoner")

query = st.text_input("Enter your question:")

if st.button("Reason"):
    with st.spinner("Thinking step by step..."):
        response = cot_streaming_reasoning(query)  # Use non-streaming for simplicity, or adapt
        st.write(response)
        final = parse_final_answer(response)
        st.success(f"Final Answer: {final}")
</code></pre>

<p>Run with <code>streamlit run app.py</code>. This creates a web interface where users input queries and see the CoT process.</p>

<a name="Challenges-and-Best-Practices"></a>
<h2>Challenges and Best Practices</h2>

<ul>
<li><strong>Token Limits</strong>: CoT increases prompt length; use efficient models.</li>
<li><strong>Bias in Reasoning</strong>: LLMs can hallucinate steps—validate with tools (e.g., code execution for math).</li>
<li><strong>Customization</strong>: For domains like code generation, add &ldquo;Step 1: Understand requirements. Step 2: Plan code structure.&rdquo;</li>
<li><strong>Integration with Agents</strong>: Combine CoT with ReAct (Reason + Act) for tool-using agents.</li>
<li><strong>Ethics</strong>: Ensure transparency; CoT doesn&rsquo;t make AI infallible.</li>
</ul>


<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>Chain of Thought applications transform LLMs from black boxes into transparent reasoners. By building step-by-step processing into your prompts and code, you create tools that not only solve problems but explain how.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Understanding ReAct in Large Language Models]]></title>
        <link href="https://rishijeet.github.io/blog/understanding-react-in-large-language-models/"/>
        <updated>2025-08-28T08:48:16+05:30</updated>
        <id>https://rishijeet.github.io/blog/understanding-react-in-large-language-models</id>
        <content type="html"><![CDATA[<p>ReAct, short for Reasoning and Acting, is a paradigm for enhancing large language models (LLMs) by integrating verbal reasoning traces with task-specific actions. Introduced in a 2022 paper, it addresses limitations in chain-of-thought (CoT) prompting by allowing models to interact with external environments, such as APIs or databases, to gather real-time data. This makes LLMs more reliable for tasks requiring factual accuracy or multi-step planning.</p>

<p>In the evolving field of artificial intelligence, large language models (LLMs) have transformed how we approach problem-solving, but they often struggle with hallucinations—generating plausible but incorrect information—or handling tasks requiring real-world interaction. Enter ReAct (Reasoning and Acting), a prompting framework that synergizes reasoning traces with actionable steps, enabling LLMs to behave more like intelligent agents. This detailed blog explores ReAct&rsquo;s foundations, mechanics, advantages, and practical implementation, culminating in a sample Python application using LangChain. We&rsquo;ll draw on established research and code examples to provide a comprehensive guide, updated with insights as of 2025.</p>

<a name="How-ReAct-Works"></a>
<h2>How ReAct Works</h2>

<p>In ReAct, the LLM generates a &ldquo;thought&rdquo; to plan, selects an &ldquo;action&rdquo; from available tools, observes the outcome, and iterates. This loop continues until the model outputs a final answer. For example, answering &ldquo;What is Olivia Wilde&rsquo;s boyfriend&rsquo;s age raised to the 0.23 power?&rdquo; might involve searching for the boyfriend, then calculating the power.</p>

<p><img src="/images/2025/reAct.gif" height="300" width="900" alt="Alt text" /><em>Source: Internet</em></p>

<a name="Key-Points"></a>
<h2>Key Points</h2>

<ul>
<li><strong>ReAct Framework</strong>: It seems likely that ReAct is a prompting technique enabling LLMs to alternate between reasoning (thinking step-by-step) and acting (using tools like searches or calculations), improving accuracy on complex tasks by reducing hallucinations and incorporating external information.</li>
<li><strong>Core Process</strong>: Evidence leans toward a loop of Thought (reasoning), Action (tool invocation), Observation (results), repeating until a final answer, mimicking human problem-solving.</li>
<li><strong>Benefits and Limitations</strong>: Research suggests ReAct enhances interpretability and performance on knowledge-intensive and decision-making tasks, though it may increase computational costs and rely on well-defined tools; it&rsquo;s particularly useful for dynamic environments but less so for simple queries.</li>
</ul>


<!--more-->


<a name="Foundations-of-ReAct"></a>
<h2>Foundations of ReAct</h2>

<p>ReAct was introduced in the 2022 paper &ldquo;ReAct: Synergizing Reasoning and Acting in Language Models&rdquo; by Shunyu Yao et al. It builds on chain-of-thought (CoT) prompting, where LLMs break down problems into intermediate reasoning steps for better performance on tasks like arithmetic or commonsense reasoning. However, CoT relies solely on the model&rsquo;s internal knowledge, leading to issues like factual errors or outdated information.</p>

<p>ReAct addresses this by interleaving reasoning (&ldquo;thoughts&rdquo;) with actions, allowing the model to query external sources (e.g., search engines, calculators, or databases) and incorporate observations back into its reasoning process. This creates a feedback loop inspired by human cognition: think, act, observe, and adjust. As of 2025, ReAct remains a cornerstone for building LLM agents, integrated into frameworks like LangChain and LangGraph, with enhancements for multi-agent systems and reduced latency.</p>

<p>Key components include:</p>

<ul>
<li><strong>Thought</strong>: A verbalized reasoning step where the LLM plans or reflects.</li>
<li><strong>Action</strong>: Invocation of a tool, such as searching Wikipedia or running a calculation.</li>
<li><strong>Observation</strong>: The result from the action, fed back to the LLM.</li>
<li><strong>Final Answer</strong>: Output when the loop concludes, often after several iterations.</li>
</ul>


<p>This structure improves trustworthiness by making the process interpretable—users can trace how the model arrived at an answer.</p>

<a name="How-ReAct-Works:-A-Step-2d-by-2d-Step-Breakdown"></a>
<h2>How ReAct Works: A Step-by-Step Breakdown</h2>

<p>ReAct operates in an iterative loop, typically capped at a maximum number of turns to control costs and latency. Here&rsquo;s the flow:</p>

<ol>
<li><strong>Initialization</strong>: The LLM receives a prompt outlining the ReAct format (e.g., &ldquo;You run in a loop of Thought, Action, PAUSE, Observation&rdquo;).</li>
<li><strong>Thought Generation</strong>: The model reasons about the query, deciding on the next action.</li>
<li><strong>Action Execution</strong>: If an action is needed, the system pauses, executes the tool, and returns an observation.</li>
<li><strong>Observation Integration</strong>: The observation is appended to the prompt, and the loop repeats.</li>
<li><strong>Termination</strong>: The model outputs &ldquo;Answer&rdquo; when confident, or hits the iteration limit.</li>
</ol>


<p>For instance, in a knowledge-intensive task like HotpotQA (multi-hop question answering), ReAct might search for &ldquo;Colorado orogeny,&rdquo; observe the result, reason about the eastern sector, and lookup further details until answering the elevation range.</p>

<p>ReAct excels in domains like:</p>

<ul>
<li><strong>Knowledge Tasks</strong>: Outperforms CoT by accessing external info, reducing hallucinations.</li>
<li><strong>Decision-Making</strong>: Handles interactive environments (e.g., games or web navigation) via tools.</li>
<li><strong>Agentic Workflows</strong>: Integrates with RAG or multi-agent systems for complex automation.</li>
</ul>


<p>However, challenges include dependency on tool quality, potential for infinite loops without safeguards, and higher token usage compared to simpler prompts.</p>

<a name="Comparisons:-ReAct-vs.-Other-LLM-Techniques"></a>
<h2>Comparisons: ReAct vs. Other LLM Techniques</h2>

<p>To contextualize ReAct, consider this comparison table:</p>

<div class="scrollable-table-container">
  <table class="scrollable-table">
  <thead>
    <tr>
      <th>Technique</th>
      <th>Description</th>
      <th>Strengths</th>
      <th>Weaknesses</th>
      <th>Use Cases</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>Chain-of-Thought (CoT)</b></td>
      <td>Prompts LLMs to reason step-by-step without external actions.</td>
      <td>Simple, low-cost; good for internal logic.</td>
      <td>Prone to hallucinations; no real-world interaction.</td>
      <td>Arithmetic, commonsense QA.</td>
    </tr>
    <tr>
      <td><b>ReAct</b></td>
      <td>Interleaves reasoning with tool-based actions and observations.</td>
      <td>Dynamic, factual; interpretable loop.</td>
      <td>Higher latency; tool-dependent.</td>
      <td>Multi-hop QA, web tasks, agents.</td>
    </tr>
    <tr>
      <td><b>Function Calling</b></td>
      <td>Fine-tuned models output JSON for tool calls, without explicit reasoning.</td>
      <td>Fast, structured; efficient for predictable tasks.</td>
      <td>Less adaptable; opaque reasoning.</td>
      <td>API integrations, simple tools.</td>
    </tr>
    <tr>
      <td><b>ReAct + CoT</b></td>
      <td>Hybrid: Uses ReAct for actions and CoT for pure reasoning switches.</td>
      <td>Optimal performance; flexible.</td>
      <td>Complex implementation.</td>
      <td>Advanced agents, hybrid tasks.</td>
    </tr>
  </tbody>
</table>
</div>


<p>ReAct often outperforms baselines on benchmarks like HotpotQA, Fever, ALFWorld, and WebShop, with gains in accuracy and efficiency when combined with CoT.</p>

<a name="Building-a-Sample-ReAct-Application-in-Python"></a>
<h2>Building a Sample ReAct Application in Python</h2>

<p>A basic ReAct agent can be built using Python libraries like LangChain. The sample below creates an agent that searches the web and performs math, demonstrating the loop in action. You&rsquo;ll need API keys for an LLM (e.g., OpenAI) and tools (e.g., Google Serper for search). For full code and setup, see the detailed survey below. This sample creates an agent that answers questions by searching the web (via Tavily) and performing calculations. It demonstrates the full loop and includes conversational memory for multi-turn interactions.</p>

<a name="Prerequisites"></a>
<h3>Prerequisites</h3>

<ul>
<li>Python 3.10+.</li>
<li>Install dependencies: <code>pip install -U langgraph langchain-tavily langgraph-checkpoint-sqlite langchain-openai</code>.</li>
<li>API Keys: Obtain OpenAI (for the LLM) and Tavily (for search) keys. Set them as environment variables:
<code>python
import os
import getpass
os.environ["OPENAI_API_KEY"] = getpass.getpass("OpenAI API Key: ")
os.environ["TAVILY_API_KEY"] = getpass.getpass("Tavily API Key: ")
</code></li>
<li>For tracing (optional): Set LangSmith keys.</li>
</ul>


<a name="Code-Implementation"></a>
<h3>Code Implementation</h3>

<p>The application uses LangGraph&rsquo;s <code>create_react_agent</code> for the ReAct logic. Here&rsquo;s the complete code:</p>

<pre><code class="python"># Import necessary modules
from langchain_tavily import TavilySearchResults
from langchain_openai import ChatOpenAI
from langgraph.prebuilt import create_react_agent
from langgraph.checkpointer import MemorySaver
from langchain_core.messages import HumanMessage

# Define tools
tool = TavilySearchResults(max_results=2)
tools = [tool]

# Initialize the LLM (using OpenAI's GPT-4o-mini for efficiency)
model = ChatOpenAI(model="gpt-4o-mini", temperature=0)

# Bind tools to the model
model_with_tools = model.bind_tools(tools)

# Create the agent with memory (using MemorySaver for conversational state)
memory = MemorySaver()
agent_executor = create_react_agent(model_with_tools, tools, checkpointer=memory)

# Configuration for conversational thread (use a unique ID for each conversation)
config = {"configurable": {"thread_id": "conversation-1"}}

# Function to run the agent
def run_agent(query):
    print(f"User Query: {query}")
    for chunk in agent_executor.stream(
        {"messages": [HumanMessage(content=query)]}, config
    ):
        print(chunk)
        print("----")
    # Extract final response
    response = chunk.get("agent", {}).get("messages", [{}])[0].content
    return response

# Example usage
query = "Who is the current CEO of xAI? What is their age squared?"
response = run_agent(query)
print(f"Final Answer: {response}")
</code></pre>

<a name="Detailed-Explanation"></a>
<h3>Detailed Explanation</h3>

<ol>
<li><strong>Tools Definition</strong>: <code>TavilySearchResults</code> is a web search tool returning up to 2 results. It&rsquo;s added to <code>tools</code> for the agent to use.</li>
<li><strong>LLM Setup</strong>: <code>ChatOpenAI</code> initializes the model (e.g., GPT-4o-mini for cost-effectiveness). <code>bind_tools</code> informs the model about available actions.</li>
<li><strong>Agent Creation</strong>: <code>create_react_agent</code> builds the ReAct loop, with <code>MemorySaver</code> enabling state persistence for follow-ups (e.g., &ldquo;Tell me more about them&rdquo;).</li>
<li><strong>Execution</strong>: The <code>stream</code> method runs the agent, printing intermediate thoughts, actions, and observations. For the example query:

<ul>
<li>Thought: Reason about searching for xAI CEO.</li>
<li>Action: Invoke Tavily search.</li>
<li>Observation: Retrieve CEO (e.g., Elon Musk) and age.</li>
<li>Thought: Calculate age squared.</li>
<li>Final Answer: Output the result (e.g., &ldquo;Elon Musk, age 54 squared is 2916&rdquo;).</li>
</ul>
</li>
<li><strong>Extensions</strong>: Add more tools (e.g., math via <code>LLMMathChain</code>) or integrate with databases for custom applications.</li>
</ol>


<a name="Testing-and-Output"></a>
<h3>Testing and Output</h3>

<p>Running the code might yield:</p>

<ul>
<li>Intermediate: Thought → Action (search) → Observation → Thought (calculate) → Answer.
This ensures factual grounding, e.g., verifying current data as of 2025.</li>
</ul>


<a name="Advanced-Variations-and-Best-Practices"></a>
<h2>Advanced Variations and Best Practices</h2>

<ul>
<li><strong>Simple Non-LangChain Implementation</strong>: For a lightweight version, use a custom loop with OpenAI&rsquo;s API, as in Simon Willison&rsquo;s example. Define actions like <code>wikipedia</code> and parse responses with regex.</li>
<li><strong>With LangGraph</strong>: For production, use LangGraph for visual workflows and error handling.</li>
<li><strong>Best Practices</strong>: Limit iterations (e.g., max_turns=5), use verbose mode for debugging, and combine with CoT for hybrid prompting. Monitor token usage, as ReAct can be resource-intensive.</li>
<li><strong>2025 Updates</strong>: Recent integrations include multimodal support (e.g., image analysis tools) and edge deployment for low-latency agents.</li>
</ul>


<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>ReAct represents a pivotal shift toward agentic AI, empowering LLMs to not just generate text but actively engage with the world. By implementing the sample above, developers can experiment and scale to real-world applications like automated research or virtual assistants.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Deep Dive into Context: MCP, A2A and RAG]]></title>
        <link href="https://rishijeet.github.io/blog/deep-dive-into-context-mcp-a2a-and-rag/"/>
        <updated>2025-08-25T08:48:32+05:30</updated>
        <id>https://rishijeet.github.io/blog/deep-dive-into-context-mcp-a2a-and-rag</id>
        <content type="html"><![CDATA[<p>RAG combines retrieval from external sources with LLM generation to produce informed responses. For instance, it
retrieves documents from a vector store before prompting the model.</p>

<p>MCP, introduced by Anthropic, acts as a &ldquo;USB-C for AI,&rdquo; allowing models to dynamically access tools and data via a client-server model. It supports prompts, resources, and tools for contextual enhancement.</p>

<p>A2A, developed by Google, enables agents to exchange tasks and results over HTTP, using Agent Cards for discovery. It&rsquo;s modality-agnostic, supporting text, images, and more.</p>

<p>Related terms include ReAct (reasoning + acting loop for decision-making) and ACP (local-first agent coordination, differing from A2A&rsquo;s web-native focus).</p>

<p><img src="/images/2025/mcp_rag_a2a.webp" height="300" width="900" alt="Alt text" /><em>Source: Internet</em></p>

<!--more-->


<a name="Key-Points"></a>
<h3>Key Points</h3>

<ul>
<li><strong>RAG (Retrieval-Augmented Generation)</strong>: Enhances AI responses by retrieving relevant external data before generating output, reducing hallucinations and incorporating up-to-date information. It seems likely that RAG is ideal for knowledge-intensive tasks like question-answering, though it may not handle real-time actions.</li>
<li><strong>MCP (Model Context Protocol)</strong>: A standardized protocol for connecting AI agents to external tools, data sources, and prompts, enabling dynamic interactions. Research suggests MCP improves single-agent efficiency by providing a universal interface, but it focuses on tool access rather than multi-agent collaboration.</li>
<li><strong>A2A (Agent-to-Agent)</strong>: An open protocol for AI agents to communicate, discover capabilities, and delegate tasks across systems. Evidence leans toward A2A fostering teamwork among agents, acknowledging potential challenges in coordination for complex, debated scenarios like multi-vendor integrations.</li>
<li><strong>Key Differences</strong>: RAG prioritizes knowledge augmentation, MCP enables tool integration for individual agents, and A2A facilitates inter-agent communication. These techniques complement each other, with no one-size-fits-all approach—RAG suits static data queries, MCP for action-oriented tasks, and A2A for collaborative workflows.</li>
<li><strong>Analogy for Easy Recall</strong>: Imagine solving a puzzle as a team. RAG is like consulting a reference book for missing pieces (knowledge retrieval). MCP is equipping yourself with tools like scissors or glue to manipulate pieces (tool access). A2A is discussing with teammates to share pieces and strategies (agent collaboration). This highlights how RAG provides info, MCP enables actions, and A2A promotes sharing.</li>
</ul>


<a name="Key-Differences"></a>
<h2>Key Differences</h2>

<div class="scrollable-table-container">
  <table class="scrollable-table">
  <thead>
    <tr>
      <th>Aspect</th>
      <th>RAG</th>
      <th>MCP</th>
      <th>A2A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Primary Focus</td>
      <td>Knowledge retrieval &amp; generation</td>
      <td>Agent-tool/data integration</td>
      <td>Inter-agent communication</td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>Q&amp;A, summarization</td>
      <td>Task automation, real-time data</td>
      <td>Collaboration, task delegation</td>
    </tr>
    <tr>
      <td>Interaction</td>
      <td>Retrieve → Augment → Generate</td>
      <td>Client → Server → Tool</td>
      <td>Client Agent → Remote Agent</td>
    </tr>
    <tr>
      <td>Strengths</td>
      <td>Reduces hallucinations</td>
      <td>Standardized access</td>
      <td>Vendor-neutral scalability</td>
    </tr>
    <tr>
      <td>Limitations</td>
      <td>Static knowledge bases</td>
      <td>Single-agent oriented</td>
      <td>Requires network connectivity</td>
    </tr>
  </tbody>
</table>
</div>


<a name="Python-Code-Examples"></a>
<h3>Python Code Examples</h3>

<p>Here&rsquo;s how to implement basic versions of each.</p>

<p><strong>RAG Example (using LangChain)</strong>:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class='line'><span class="kn">from</span> <span class="nn">langchain_openai</span> <span class="kn">import</span> <span class="n">OpenAIEmbeddings</span><span class="p">,</span> <span class="n">ChatOpenAI</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">langchain_community.vectorstores</span> <span class="kn">import</span> <span class="n">Chroma</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">langchain_core.prompts</span> <span class="kn">import</span> <span class="n">PromptTemplate</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">langchain_core.runnables</span> <span class="kn">import</span> <span class="n">RunnablePassthrough</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">langchain_core.output_parsers</span> <span class="kn">import</span> <span class="n">StrOutputParser</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Sample-documents&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Sample</span> <span class="n">documents</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">docs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Document</span> <span class="mi">1</span> <span class="n">content</span><span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Document</span> <span class="mi">2</span> <span class="n">content</span><span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Embed-and-store&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Embed</span> <span class="ow">and</span> <span class="n">store</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">embeddings</span> <span class="o">=</span> <span class="n">OpenAIEmbeddings</span><span class="p">()</span>
</span><span class='line'><span class="n">vectorstore</span> <span class="o">=</span> <span class="n">Chroma</span><span class="o">.</span><span class="n">from_texts</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">)</span>
</span><span class='line'><span class="n">retriever</span> <span class="o">=</span> <span class="n">vectorstore</span><span class="o">.</span><span class="n">as_retriever</span><span class="p">()</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Prompt-template&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Prompt</span> <span class="n">template</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">template</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Use</span> <span class="n">the</span> <span class="n">following</span> <span class="n">context</span> <span class="n">to</span> <span class="n">answer</span> <span class="n">the</span> <span class="n">question</span><span class="p">:</span>
</span><span class='line'><span class="p">{</span><span class="n">context</span><span class="p">}</span>
</span><span class='line'><span class="n">Question</span><span class="p">:</span> <span class="p">{</span><span class="n">question</span><span class="p">}</span>
</span><span class='line'><span class="n">Answer</span><span class="p">:</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'><span class="n">prompt</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span><span class="n">template</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;LLM&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">LLM</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">llm</span> <span class="o">=</span> <span class="n">ChatOpenAI</span><span class="p">(</span><span class="n">model</span><span class="o">=&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">gpt</span><span class="o">-</span><span class="mi">4</span><span class="n">o</span><span class="o">-</span><span class="n">mini</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Chain&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Chain</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">chain</span> <span class="o">=</span> <span class="p">(</span>
</span><span class='line'>    <span class="p">{</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">context</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;:</span> <span class="n">retriever</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">question</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;:</span> <span class="n">RunnablePassthrough</span><span class="p">()}</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">prompt</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">llm</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">StrOutputParser</span><span class="p">()</span>
</span><span class='line'><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Usage&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Usage</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Your</span> <span class="n">question</span> <span class="n">here</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</span></code></pre></div></figure>
This retrieves relevant docs, augments the prompt, and generates a response.</p>

<p><strong>MCP Example (using FastMCP)</strong>:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class='line'><span class="kn">from</span> <span class="nn">fastmcp</span> <span class="kn">import</span> <span class="n">FastMCP</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">mcp</span> <span class="o">=</span> <span class="n">FastMCP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Demo</span> <span class="n">Server</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nd">@mcp.tool</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">search_docs</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'><span class="n">async</span> <span class="k">def</span> <span class="nf">search_docs</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Search</span> <span class="k">for</span> <span class="n">documentation</span> <span class="n">related</span> <span class="n">to</span> <span class="n">the</span> <span class="n">query</span><span class="o">.&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">f</span><span class="s">&quot;Results for: {query}&quot;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nd">@mcp.prompt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">code_review</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'><span class="n">async</span> <span class="k">def</span> <span class="nf">code_review</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Return</span> <span class="n">a</span> <span class="n">template</span> <span class="k">for</span> <span class="n">code</span> <span class="n">review</span><span class="o">.&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Review</span> <span class="n">the</span> <span class="n">following</span> <span class="n">code</span> <span class="k">for</span><span class="p">:</span>\<span class="n">n</span><span class="o">-</span> <span class="n">Bugs</span>\<span class="n">n</span><span class="o">-</span> <span class="n">Efficiency</span>\<span class="n">n</span><span class="o">-</span> <span class="n">Readability</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">name</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">main</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;&amp;</span><span class="n">rdquo</span><span class="p">;:</span>
</span><span class='line'>    <span class="n">mcp</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</span></code></pre></div></figure>
This sets up an MCP server with a tool and prompt, connectable via clients like Claude Desktop.</p>

<p><strong>A2A Example (using Python A2A SDK)</strong>:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><pre><code class="python"><span class='line'><span class="kn">from</span> <span class="nn">a2a</span> <span class="kn">import</span> <span class="n">AgentSkill</span><span class="p">,</span> <span class="n">AgentCard</span><span class="p">,</span> <span class="n">A2AServer</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Define-skill&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Define</span> <span class="n">skill</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">skill</span> <span class="o">=</span> <span class="n">AgentSkill</span><span class="p">(</span>
</span><span class='line'>    <span class="nb">id</span><span class="o">=&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">hello_world</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span>
</span><span class='line'>    <span class="n">name</span><span class="o">=&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">Returns</span> <span class="n">hello</span> <span class="n">world</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span>
</span><span class='line'>    <span class="n">description</span><span class="o">=&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">Just</span> <span class="n">returns</span> <span class="n">hello</span> <span class="n">world</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span>
</span><span class='line'>    <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">hello</span> <span class="n">world</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;],</span>
</span><span class='line'>    <span class="n">examples</span><span class="o">=</span><span class="p">[</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">hi</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">hello</span> <span class="n">world</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;]</span>
</span><span class='line'><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Define-Agent-Card&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Define</span> <span class="n">Agent</span> <span class="n">Card</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">card</span> <span class="o">=</span> <span class="n">AgentCard</span><span class="p">(</span>
</span><span class='line'>    <span class="n">name</span><span class="o">=&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">Hello</span> <span class="n">World</span> <span class="n">Agent</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span>
</span><span class='line'>    <span class="n">description</span><span class="o">=&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">A</span> <span class="n">simple</span> <span class="n">hello</span> <span class="n">world</span> <span class="n">agent</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span>
</span><span class='line'>    <span class="n">skills</span><span class="o">=</span><span class="p">[</span><span class="n">skill</span><span class="p">],</span>
</span><span class='line'>    <span class="n">service_url</span><span class="o">=&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;http://localhost:8000&quot;</span><span class="o">&gt;</span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">localhost</span><span class="p">:</span><span class="mi">8000</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Agent-logic&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Agent</span> <span class="n">logic</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">hello_world_handler</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Hello</span><span class="p">,</span> <span class="n">World</span><span class="err">!</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Run-server&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Run</span> <span class="n">server</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">server</span> <span class="o">=</span> <span class="n">A2AServer</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">hello_world</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;:</span> <span class="n">hello_world_handler</span><span class="p">})</span>
</span><span class='line'><span class="n">server</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">port</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
</span></code></pre></div></figure>
This creates an A2A server; other agents can discover it via the Agent Card and send tasks.</p>

<hr />

<p>In the evolving landscape of AI, techniques like Retrieval-Augmented Generation (RAG), Model Context Protocol (MCP), and Agent-to-Agent (A2A) represent foundational advancements in making large language models (LLMs) more capable, interactive, and collaborative. These methods address key limitations of standalone LLMs, such as outdated knowledge, isolation from tools, and lack of multi-entity coordination. Below, we delve into detailed explanations, architectural insights, comparisons, real-world applications, and implementation guidance, expanding on the core concepts introduced earlier. This comprehensive overview incorporates practical considerations, potential challenges, and synergies among these techniques, drawing from established sources and best practices.</p>

<a name="In-2d-Depth-Explanations-of-Core-Terms"></a>
<h2>In-Depth Explanations of Core Terms</h2>

<a name="Retrieval-2d-Augmented-Generation--28-RAG-29-"></a>
<h3>Retrieval-Augmented Generation (RAG)</h3>

<p>RAG is a hybrid approach that combines information retrieval with generative AI to produce more accurate and contextually grounded responses. Introduced as a way to mitigate LLM hallucinations—where models generate plausible but incorrect information—RAG works by first querying an external knowledge base (e.g., a vector database) for relevant documents, then feeding these into the LLM&rsquo;s prompt for generation.</p>

<ul>
<li><p><strong>How It Works</strong>:</p>

<ul>
<li><strong>Retrieval</strong>: Embed the user query using models like OpenAI&rsquo;s text-embedding-3-large and search a vector store (e.
g., ChromaDB or FAISS) for similar documents via cosine similarity.</li>
<li><strong>Augmentation</strong>: Inject retrieved content into the prompt, e.g., &ldquo;Use this context: [retrieved docs] to answer
  [query].&rdquo;</li>
<li><strong>Generation</strong>: The LLM (e.g., GPT-4o-mini) processes the augmented prompt to output a response.</li>
</ul>
</li>
<li><p><strong>Benefits</strong>: Improves factual accuracy, handles domain-specific or real-time data, and is cost-effective compared to fine-tuning. For example, in chatbots, RAG can pull from company docs to answer queries accurately.</p></li>
<li><strong>Challenges</strong>: Retrieval quality depends on embedding models and index freshness; irrelevant docs can dilute responses.</li>
<li><strong>Related Concepts</strong>: Often paired with semantic search or hybrid retrieval (keyword + vector) for better results.</li>
</ul>


<a name="Model-Context-Protocol--28-MCP-29-"></a>
<h3>Model Context Protocol (MCP)</h3>

<p>MCP is an open-source protocol from Anthropic (released in 2024) designed to standardize how AI agents access external context, including tools, data, and prompts. It acts as a bridge between LLMs and real-world systems, enabling dynamic, secure interactions without custom integrations.</p>

<ul>
<li><p><strong>How It Works</strong>:</p>

<ul>
<li><strong>Architecture</strong>: Client-server model where MCP clients (e.g., AI apps like Claude Desktop) connect to MCP servers exposing capabilities.</li>
<li><strong>Core Components</strong>:

<ul>
<li><strong>Tools</strong>: Executable functions (e.g., API calls).</li>
<li><strong>Prompts</strong>: Templates for guiding LLM behavior.</li>
<li><strong>Resources</strong>: Data sources like files or databases.</li>
</ul>
</li>
<li><strong>Protocol Flow</strong>: Clients discover capabilities via list_tools(), invoke via call_tool(), and handle responses in real-time (supports HTTP/SSE for streaming).</li>
</ul>
</li>
<li><p><strong>Benefits</strong>: Promotes interoperability, security (e.g., OAuth), and modularity. Early adopters like Block and Zed use it for agentic coding and data access.</p></li>
<li><strong>Challenges</strong>: Primarily local-first; remote integrations require additional setup. It&rsquo;s complementary to protocols like A2A for broader ecosystems.</li>
<li><strong>Related Concepts</strong>: Often used with ReAct (Reasoning + Acting), where agents reason before invoking MCP tools.</li>
</ul>


<a name="Agent-2d-to-2d-Agent--28-A2A-29-"></a>
<h3>Agent-to-Agent (A2A)</h3>

<p>A2A is Google&rsquo;s 2025 open protocol for enabling AI agents to communicate and collaborate across frameworks and vendors. It treats agents as interoperable services, allowing task delegation in multi-agent systems.</p>

<ul>
<li><p><strong>How It Works</strong>:</p>

<ul>
<li><strong>Architecture</strong>: HTTP-based with JSON-RPC for requests. Agents expose &ldquo;Agent Cards&rdquo; (JSON metadata at /.well-known/agent.json) for discovery.</li>
<li><strong>Core Components</strong>:

<ul>
<li><strong>Tasks</strong>: Stateful units of work (e.g., &ldquo;book flight&rdquo;) with lifecycles (submitted → completed).</li>
<li><strong>Messages/Artifacts</strong>: Exchange data in modalities like text or JSON.</li>
<li><strong>Skills</strong>: Defined capabilities (e.g., &ldquo;analyze data&rdquo;) with input/output specs.</li>
</ul>
</li>
<li><strong>Protocol Flow</strong>: Client agent sends task/send to remote agent, which processes and streams updates via SSE.</li>
</ul>
</li>
<li><p><strong>Benefits</strong>: Vendor-neutral (supported by 50+ partners like MongoDB), scalable for enterprise (e.g., CRM coordination), and modality-agnostic.</p></li>
<li><strong>Challenges</strong>: Network-dependent; coordination in controversial tasks (e.g., ethical AI debates) requires careful design to balance viewpoints.</li>
<li><strong>Related Concepts</strong>: Contrasts with ACP (local, low-latency focus) but integrates with MCP for tool access during collaboration.</li>
</ul>


<a name="Other-Related-Terms"></a>
<h3>Other Related Terms</h3>

<ul>
<li><strong>ReAct</strong>: A prompting technique where agents &ldquo;reason&rdquo; (think step-by-step), &ldquo;act&rdquo; (use tools), and iterate. Often combined with MCP for action loops.</li>
<li><strong>ACP (Agent Communication Protocol)</strong>: A local-first alternative to A2A, suited for edge devices (e.g., robotics) with low-latency IPC.</li>
<li><strong>Agentic AI</strong>: Broad term for autonomous agents; RAG, MCP, and A2A enable this by adding retrieval, tools, and collaboration.</li>
</ul>


<a name="Detailed-Comparisons-and-Synergies"></a>
<h2>Detailed Comparisons and Synergies</h2>

<p>While RAG, MCP, and A2A address LLM limitations, they differ in scope and application:</p>

<div class="scrollable-table-container">
  <table class="scrollable-table">
  <thead>
    <tr>
      <th>Aspect</th>
      <th>RAG</th>
      <th>MCP</th>
      <th>A2A</th>
      <th>ReAct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Goal</td>
      <td>Augment generation with knowledge</td>
      <td>Connect agents to tools/data</td>
      <td>Enable agent collaboration</td>
      <td>Iterative reasoning + acting</td>
    </tr>
    <tr>
      <td>Communication Pattern</td>
      <td>Internal (retriever → LLM)</td>
      <td>Client-server (agent → tool)</td>
      <td>Peer-to-peer (agent → agent)</td>
      <td>Loop within single agent</td>
    </tr>
    <tr>
      <td>Discovery Mechanism</td>
      <td>Vector similarity search</td>
      <td>list_tools()</td>
      <td>Agent Cards</td>
      <td>N/A (prompt-based)</td>
    </tr>
    <tr>
      <td>Standardization</td>
      <td>Implementation-specific</td>
      <td>Open protocol (Anthropic)</td>
      <td>Open protocol (Google)</td>
      <td>Prompting technique</td>
    </tr>
    <tr>
      <td>Use in Controversial Topics</td>
      <td>Balances views via diverse sources</td>
      <td>Tool access for verification</td>
      <td>Collaboration for multi-perspective analysis</td>
      <td>Reasoning to evaluate biases</td>
    </tr>
  </tbody>
</table>
</div>


<ul>
<li><strong>Synergies</strong>: In a multi-agent system, A2A could delegate retrieval to a RAG-specialized agent, which uses MCP to access tools like databases. ReAct enhances individual agents within this setup.</li>
<li><strong>When to Choose</strong>: Use RAG for info-heavy queries, MCP for single-agent automation, A2A for team-based tasks. For balanced views on debated topics (e.g., AI ethics), combine with diverse source retrieval.</li>
</ul>


<a name="Real-2d-World-Applications-and-Case-Studies"></a>
<h2>Real-World Applications and Case Studies</h2>

<ul>
<li><strong>RAG in Practice</strong>: Used in chatbots (e.g., enterprise search on internal docs) or research tools. Example: Summarizing PDFs by retrieving chunks and generating insights.</li>
<li><strong>MCP in Practice</strong>: In IDEs like Cursor for code reviews (fetching repo data) or assistants like Claude for calendar checks.</li>
<li><strong>A2A in Practice</strong>: Multi-agent workflows, e.g., a travel planner agent (A2A) delegates flight booking to a specialized agent, using MCP for API access.</li>
<li><strong>Combined Example</strong>: An AI customer service system where RAG retrieves FAQs, MCP integrates CRM tools, and A2A coordinates between query-handling and escalation agents.</li>
</ul>


<a name="Advanced-Implementation-with-Python-Code"></a>
<h2>Advanced Implementation with Python Code</h2>

<p>Building on basic examples, here&rsquo;s an integrated system using all three.</p>

<p><strong>Integrated RAG + MCP + A2A Example</strong> (Hypothetical multi-agent setup with LangChain for RAG, FastMCP for MCP, and A2A SDK):</p>

<pre><code class="python"># RAG Component (as before)
# ...

# MCP Server Setup
from fastmcp import FastMCP
mcp = FastMCP("Integrated Server")
@mcp.tool("fetch_data")
async def fetch_data(query: str) -&gt; str:
    return "Data fetched: " + query  # Simulate tool

# A2A Agent Setup
from a2a import AgentSkill, AgentCard, A2AServer

skill = AgentSkill(id='integrated_task', name='Handle integrated task', description='Uses RAG, MCP')
card = AgentCard(name='Integrated Agent', skills=[skill], service_url='http://localhost:8000')

def handler(task):
    # Invoke RAG
    rag_response = chain.invoke(task['query'])
    # Invoke MCP tool
    mcp_response = fetch_data(task['query'])
    return f"RAG: {rag_response}, MCP: {mcp_response}"

server = A2AServer(card, {'integrated_task': handler})
server.run(port=8000)
</code></pre>

<p>Run the server; other A2A agents can delegate tasks here, leveraging RAG for knowledge and MCP for tools.</p>

<p>For math problems (closed-ended), e.g., solving quadratic equations via ReAct + code tool:</p>

<ul>
<li>Reasoning: Prompt agent to reason step-by-step, generate code (e.g., using sympy), execute via tool, verify.</li>
<li>Solution: For ax² + bx + c = 0, roots = [-b ± sqrt(b² - 4ac)] / 2a. Code: <code>import math; discriminant = b**2 - 4*a*c; root1 = (-b + math.sqrt(discriminant)) / (2*a); ...</code></li>
</ul>


<a name="Potential-Challenges-and-Best-Practices"></a>
<h2>Potential Challenges and Best Practices</h2>

<ul>
<li><strong>Uncertainty Handling</strong>: Hedge on controversial topics (e.g., &ldquo;Evidence suggests&hellip; but views differ&rdquo;).</li>
<li><strong>Security</strong>: Use authentication in MCP/A2A; validate retrieval in RAG.</li>
<li><strong>Scalability</strong>: Combine for agentic workflows; monitor with tools like LangSmith.</li>
<li><strong>Future Outlook</strong>: As AI evolves, these may integrate further, enabling fully autonomous systems.</li>
</ul>


<p>This survey provides a self-contained guide, ensuring you can implement and adapt these techniques effectively.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Enhancing Natural Language Processing with Retrieval-Augmented Generation]]></title>
        <link href="https://rishijeet.github.io/blog/enhancing-natural-language-processing-with-retrieval-augmented-generation/"/>
        <updated>2024-01-13T20:34:07+05:30</updated>
        <id>https://rishijeet.github.io/blog/enhancing-natural-language-processing-with-retrieval-augmented-generation</id>
        <content type="html"><![CDATA[<p>Natural Language Processing (NLP) has witnessed remarkable advancements in recent years, with the advent of sophisticated language models like GPT-3 (Generative Pre-trained Transformer 3). However, one of the challenges that still persists in NLP is the generation of coherent and contextually relevant content. Retrieval-Augmented Generation (RAG) emerges as a powerful solution to address this issue, combining the strengths of both retrieval-based and generation-based approaches.</p>

<a name="Understanding-Retrieval-2d-Augmented-Generation"></a>
<h1>Understanding Retrieval-Augmented Generation</h1>

<p>Retrieval-Augmented Generation is a hybrid approach that integrates the benefits of information retrieval systems with generative models. Let&rsquo;s delve into the mathematical formulations of the key components of RAG.</p>

<p><img src="/images/rag_new.png" height="300" width="900" alt="Alt text" /> Figure: Overview of our approach. We combine a pre-trained retriever <em>(Query Encoder + Document Index)</em> with a pre-trained seq2seq model <em>(Generator)</em> and fine-tune end-to-end. For query \(x\), we use Maximum Inner Product Search (MIPS) to find the top-\(K\) documents \(z_i\). For the final prediction \(y\), we treat \(z\) as a latent variable and marginalize over seq2seq predictions given different documents. <em><a href="https://arxiv.org/pdf/2005.11401.pdf">Source: arxiv.org</a></em></p>

<!-- more -->


<a name="L1.-Generative-Model"></a>
<h2>1. Generative Model</h2>

<p>The generative model in RAG is often based on a pre-trained transformer architecture, such as GPT-3. The core functionality involves generating text given a context. Mathematically, the generative model can be represented as:</p>

<p><div>
<span>
\[ P_{\text{gen}}(Y|X) \]
</span>
where \( Y \) is the generated text and \( X \) is the input context. This probability distribution captures the likelihood of generating \( Y \) given \( X \).
<div></p>

<a name="L2.-Retrieval-Model"></a>
<h2>2. Retrieval Model</h2>

<p>The retrieval model is responsible for fetching relevant information from a knowledge base. This can be achieved through techniques like dense retrieval using embeddings. The retrieval model computes the similarity between the input query and the documents in the knowledge base. Mathematically, this can be expressed as:
<div>
\[ \text{argmax}_{d \in \text{KnowledgeBase}} \text{similarity}(Q, \text{Embed}(d)) \]</p>

<p>where \( Q \) is the query, \( \text{KnowledgeBase} \) is the set of documents, \( d \) represents a document, \( \text{Embed}(\cdot) \) denotes the embedding function, and \( \text{similarity}(\cdot) \) measures the similarity between the query and document embeddings.
</div></p>

<a name="L3.-Indexing-Mechanism"></a>
<h2>3. Indexing Mechanism</h2>

<p>Indexing mechanisms play a crucial role in efficiently retrieving information. Commonly, techniques like approximate nearest neighbors are employed. Mathematically, indexing involves mapping documents to a space such that retrieval operations are expedited. This can be represented as:</p>

<div>
&#92;[ \text{Index}(d) \rightarrow \text{Embed}(d) &#92;]

where &#92;( \text{Index}(\cdot) &#92;) denotes the indexing function mapping documents to their embeddings.
</div>


<a name="L4.-Context-2d-Aware-Integration"></a>
<h2>4. Context-Aware Integration</h2>

<p>To integrate retrieved information into the generative process while maintaining context, the retrieval model output needs to be combined with the generative model&rsquo;s output. A simple formulation for context-aware integration can be:</p>

<div>
<span>
&#92;[ P_{\text{final}}(Y|X, Q) = \alpha \cdot P_{\text{gen}}(Y|X) + (1-\alpha) \cdot P_{\text{ret}}(Y|Q) &#92;]
</span>
where &#92;( P_{\text{final}}(Y|X, Q) &#92;) is the final probability distribution of generating &#92;( Y &#92;) given &#92;( X &#92;) and &#92;( Q &#92;), \( \alpha \) is a hyperparameter controlling the balance between generative and retrieval components, and \( P_{\text{ret}}(Y|Q) \) is the probability distribution of generating \( Y \) given the retrieved information \( Q \).
</div>


<a name="Advantages-of-Retrieval-2d-Augmented-Generation"></a>
<h1>Advantages of Retrieval-Augmented Generation</h1>

<ol>
<li><p><strong>Improved Relevance:</strong>
By integrating information retrieval, RAG ensures that the generated content is contextually relevant and grounded in factual accuracy. This is particularly beneficial in applications where precision and relevance are critical, such as question-answering systems.</p></li>
<li><p><strong>Addressing Data Sparsity:</strong>
In scenarios where training data is limited, RAG can leverage external knowledge bases to compensate for the lack of specific information. This makes the model more robust and capable of handling a broader range of topics.</p></li>
<li><p><strong>Contextual Enrichment:</strong>
The retrieval-augmented approach allows for the enrichment of generated content by pulling in relevant details from a diverse set of sources. This not only enhances the quality of the generated text but also broadens the scope of information covered.</p></li>
<li><p><strong>Reduced Ambiguity:</strong>
Integrating retrieval mechanisms helps in disambiguating the meaning of ambiguous terms or phrases by pulling in contextually appropriate information from the knowledge base.</p></li>
</ol>


<a name="Applications-of-Retrieval-2d-Augmented-Generation"></a>
<h1>Applications of Retrieval-Augmented Generation</h1>

<ol>
<li><p><strong>Question Answering Systems:</strong>
RAG is particularly effective in question-answering systems where precise and contextually relevant answers are essential. The retrieval model can fetch information from a knowledge base to support or augment the generative model&rsquo;s response.</p></li>
<li><p><strong>Content Creation:</strong>
In content creation tasks, such as article writing or summarization, RAG can enhance the coherence and factual accuracy of the generated content by pulling in information from external sources.</p></li>
<li><p><strong>Dialog Systems:</strong>
Conversational agents can benefit from RAG by providing more informative and contextually relevant responses. The retrieval model aids in quickly accessing relevant information to support the generative model&rsquo;s output during a conversation.</p></li>
</ol>


<a name="Challenges-and-Future-Directions"></a>
<h1>Challenges and Future Directions</h1>

<p>While Retrieval-Augmented Generation shows great promise, it is not without its challenges. Fine-tuning the balance between the generative and retrieval components, handling diverse knowledge bases, and addressing potential biases in retrieved information are areas that require further research. Additionally, exploring ways to dynamically update the knowledge base during the generative process could open new possibilities for real-time applications.</p>

<p>In conclusion, Retrieval-Augmented Generation represents a significant step forward in enhancing the capabilities of natural language processing systems. By seamlessly integrating the strengths of generative and retrieval models, RAG holds the potential to revolutionize various NLP applications, making them more accurate, contextually aware, and capable of handling a wide range of tasks. As research in this field continues to progress, we can expect even more sophisticated and versatile language models that leverage the best of both worlds.</p>
]]></content>
    </entry>
    
</feed>
